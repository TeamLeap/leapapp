<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width" charset="utf-8">
    <title>My Project</title>
    <link rel="stylesheet" href="../css/bootstrap.min.css">
    <link rel="stylesheet" href="../css/cayman.min.css">
    <link rel="stylesheet" href="../css/prism.min.css">
    <link rel="stylesheet" href="../css/index.min.css">
    <link rel="stylesheet" href="../css/docs.min.css">
    <link rel="stylesheet" href="../css/bootstrap-responsive.min.css">
  </head>
  <body data-spy="scroll" data-target=".scrollspy">
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container"><a class="brand">Mr. Doc</a>
          <div class="nav-collapse collapse">
            <ul class="nav pull-right sponsored"></ul>
          </div>
        </div>
      </div>
    </div>
    <header id="overview" class="jumbotron subhead">
      <div class="container">
        <h1>My Project</h1>
        <p class="lead"></p>
      </div>
    </header>
    <div class="container">
      <div class="row">
        <div class="span3 bs-docs-sidebar">
          <ul class="nav nav-list bs-docs-sidenav affix-top">
            <li><a href="../index.html">Main</a></li>
            <li><a href="../bower_components/Chart.js.html">bower_components/Chart.js</a></li>
            <li><a href="../bower_components/Chart.js/dist/Chart.bundle.js.html">bower_components/Chart.js/dist/Chart.bundle.js</a></li>
            <li><a href="../bower_components/Chart.js/dist/Chart.bundle.min.js.html">bower_components/Chart.js/dist/Chart.bundle.min.js</a></li>
            <li><a href="../bower_components/Chart.js/dist/Chart.js.html">bower_components/Chart.js/dist/Chart.js</a></li>
            <li><a href="../bower_components/Chart.js/dist/Chart.min.js.html">bower_components/Chart.js/dist/Chart.min.js</a></li>
            <li><a href="../bower_components/Chart.js/gulpfile.js.html">bower_components/Chart.js/gulpfile.js</a></li>
            <li><a href="../bower_components/Chart.js/karma.conf.ci.js.html">bower_components/Chart.js/karma.conf.ci.js</a></li>
            <li><a href="../bower_components/Chart.js/karma.conf.js.html">bower_components/Chart.js/karma.conf.js</a></li>
            <li><a href="../bower_components/Chart.js/karma.coverage.conf.js.html">bower_components/Chart.js/karma.coverage.conf.js</a></li>
            <li><a href="../bower_components/Chart.js/src/chart.js.html">bower_components/Chart.js/src/chart.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Bar.js.html">bower_components/Chart.js/src/charts/Chart.Bar.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Bubble.js.html">bower_components/Chart.js/src/charts/Chart.Bubble.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Doughnut.js.html">bower_components/Chart.js/src/charts/Chart.Doughnut.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Line.js.html">bower_components/Chart.js/src/charts/Chart.Line.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.PolarArea.js.html">bower_components/Chart.js/src/charts/Chart.PolarArea.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Radar.js.html">bower_components/Chart.js/src/charts/Chart.Radar.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Scatter.js.html">bower_components/Chart.js/src/charts/Chart.Scatter.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.bar.js.html">bower_components/Chart.js/src/controllers/controller.bar.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.bubble.js.html">bower_components/Chart.js/src/controllers/controller.bubble.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.doughnut.js.html">bower_components/Chart.js/src/controllers/controller.doughnut.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.line.js.html">bower_components/Chart.js/src/controllers/controller.line.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.polarArea.js.html">bower_components/Chart.js/src/controllers/controller.polarArea.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.radar.js.html">bower_components/Chart.js/src/controllers/controller.radar.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.animation.js.html">bower_components/Chart.js/src/core/core.animation.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.controller.js.html">bower_components/Chart.js/src/core/core.controller.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.datasetController.js.html">bower_components/Chart.js/src/core/core.datasetController.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.element.js.html">bower_components/Chart.js/src/core/core.element.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.helpers.js.html">bower_components/Chart.js/src/core/core.helpers.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.js.html">bower_components/Chart.js/src/core/core.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.layoutService.js.html">bower_components/Chart.js/src/core/core.layoutService.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.legend.js.html">bower_components/Chart.js/src/core/core.legend.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.plugin.js.html">bower_components/Chart.js/src/core/core.plugin.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.scale.js.html">bower_components/Chart.js/src/core/core.scale.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.scaleService.js.html">bower_components/Chart.js/src/core/core.scaleService.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.title.js.html">bower_components/Chart.js/src/core/core.title.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.tooltip.js.html">bower_components/Chart.js/src/core/core.tooltip.js</a></li>
            <li><a href="../bower_components/Chart.js/src/elements/element.arc.js.html">bower_components/Chart.js/src/elements/element.arc.js</a></li>
            <li><a href="../bower_components/Chart.js/src/elements/element.line.js.html">bower_components/Chart.js/src/elements/element.line.js</a></li>
            <li><a href="../bower_components/Chart.js/src/elements/element.point.js.html">bower_components/Chart.js/src/elements/element.point.js</a></li>
            <li><a href="../bower_components/Chart.js/src/elements/element.rectangle.js.html">bower_components/Chart.js/src/elements/element.rectangle.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.category.js.html">bower_components/Chart.js/src/scales/scale.category.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.linear.js.html">bower_components/Chart.js/src/scales/scale.linear.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.logarithmic.js.html">bower_components/Chart.js/src/scales/scale.logarithmic.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.radialLinear.js.html">bower_components/Chart.js/src/scales/scale.radialLinear.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.time.js.html">bower_components/Chart.js/src/scales/scale.time.js</a></li>
            <li><a href="../bower_components/angular/angular.js.html">bower_components/angular/angular.js</a></li>
            <li><a href="../bower_components/angular/angular.min.js.html">bower_components/angular/angular.min.js</a></li>
            <li><a href="../bower_components/angular/index.js.html">bower_components/angular/index.js</a></li>
            <li><a href="../bower_components/angular-charts/dist/angular-charts.js.html">bower_components/angular-charts/dist/angular-charts.js</a></li>
            <li><a href="../bower_components/angular-charts/dist/angular-charts.min.js.html">bower_components/angular-charts/dist/angular-charts.min.js</a></li>
            <li><a href="../bower_components/angular-nvd3/Gruntfile.js.html">bower_components/angular-nvd3/Gruntfile.js</a></li>
            <li><a href="../bower_components/angular-nvd3/dist/angular-nvd3.js.html">bower_components/angular-nvd3/dist/angular-nvd3.js</a></li>
            <li><a href="../bower_components/angular-nvd3/dist/angular-nvd3.min.js.html">bower_components/angular-nvd3/dist/angular-nvd3.min.js</a></li>
            <li><a href="../bower_components/angular-nvd3/index.js.html">bower_components/angular-nvd3/index.js</a></li>
            <li><a href="../bower_components/d3/d3.js.html">bower_components/d3/d3.js</a></li>
            <li><a href="../bower_components/d3/d3.min.js.html">bower_components/d3/d3.min.js</a></li>
            <li><a href="../bower_components/nvd3/build/nv.d3.js.html">bower_components/nvd3/build/nv.d3.js</a></li>
            <li><a href="../bower_components/nvd3/build/nv.d3.min.js.html">bower_components/nvd3/build/nv.d3.min.js</a></li>
            <li><a href="../bower_components/nvd3/meteor/export.js.html">bower_components/nvd3/meteor/export.js</a></li>
            <li><a href="../bower_components/nvd3/package.js.html">bower_components/nvd3/package.js</a></li>
            <li><a href="../cemetery/cemetery.controller.js.html">cemetery/cemetery.controller.js</a></li>
            <li><a href="../counsellor/counsellor.controller.js.html">counsellor/counsellor.controller.js</a></li>
            <li><a href="../docs/js/bootstrap-affix.min.js.html">docs/js/bootstrap-affix.min.js</a></li>
            <li><a href="../docs/js/bootstrap-collapse.min.js.html">docs/js/bootstrap-collapse.min.js</a></li>
            <li><a href="../docs/js/bootstrap-dropdown.min.js.html">docs/js/bootstrap-dropdown.min.js</a></li>
            <li><a href="../docs/js/bootstrap-scrollspy.min.js.html">docs/js/bootstrap-scrollspy.min.js</a></li>
            <li><a href="../docs/js/bootstrap-transition.min.js.html">docs/js/bootstrap-transition.min.js</a></li>
            <li><a href="../docs/js/index.min.js.html">docs/js/index.min.js</a></li>
            <li><a href="../docs/js/jquery.min.js.html">docs/js/jquery.min.js</a></li>
            <li><a href="../docs/js/prism.min.js.html">docs/js/prism.min.js</a></li>
            <li><a href="../docs/js/twitter-widget.min.js.html">docs/js/twitter-widget.min.js</a></li>
            <li><a href="../efleet/efleet.controller.js.html">efleet/efleet.controller.js</a></li>
            <li><a href="../ehealth/ehealth.controller.js.html">ehealth/ehealth.controller.js</a></li>
            <li><a href="../gulpfile.js.html">gulpfile.js</a></li>
            <li><a href="../hr/hr.controller.js.html">hr/hr.controller.js</a></li>
            <li><a href="../indigent/indigent.controller.js.html">indigent/indigent.controller.js</a></li>
            <li><a href="../js/app.js.html">js/app.js</a></li>
            <li><a href="../js/config.js.html">js/config.js</a></li>
            <li><a href="../js/map-icons.js.html">js/map-icons.js</a></li>
            <li><a href="../js/ng-cordova.js.html">js/ng-cordova.js</a></li>
            <li><a href="../js/oauth.js.html">js/oauth.js</a></li>
            <li><a href="../js/plugins.js.html">js/plugins.js</a></li>
            <li class="active"><a href="../js/ui-bootstrap-tpls-2.1.1.js.html">js/ui-bootstrap-tpls-2.1.1.js</a></li>
            <li><a href="../lib/angular-messages.min.js.html">lib/angular-messages.min.js</a></li>
            <li><a href="../lib/angular-nvd3.js.html">lib/angular-nvd3.js</a></li>
            <li><a href="../lib/angular.soap.js.html">lib/angular.soap.js</a></li>
            <li><a href="../lib/d3.js.html">lib/d3.js</a></li>
            <li><a href="../lib/nv.d3.js.html">lib/nv.d3.js</a></li>
            <li><a href="../lib/onsen/js/angular/angular-animate.js.html">lib/onsen/js/angular/angular-animate.js</a></li>
            <li><a href="../lib/onsen/js/angular/angular-touch.js.html">lib/onsen/js/angular/angular-touch.js</a></li>
            <li><a href="../lib/onsen/js/angular/angular.js.html">lib/onsen/js/angular/angular.js</a></li>
            <li><a href="../lib/onsen/js/angular/angular.min.js.html">lib/onsen/js/angular/angular.min.js</a></li>
            <li><a href="../lib/onsen/js/jquery-3.1.0.min.js.html">lib/onsen/js/jquery-3.1.0.min.js</a></li>
            <li><a href="../lib/onsen/js/onsenui.js.html">lib/onsen/js/onsenui.js</a></li>
            <li><a href="../lib/onsen/js/onsenui.min.js.html">lib/onsen/js/onsenui.min.js</a></li>
            <li><a href="../lib/onsen/js/onsenui_all.js.html">lib/onsen/js/onsenui_all.js</a></li>
            <li><a href="../lib/onsen/js/onsenui_all.min.js.html">lib/onsen/js/onsenui_all.min.js</a></li>
            <li><a href="../lib/signature_pad.js.html">lib/signature_pad.js</a></li>
            <li><a href="../lib/soapclient.js.html">lib/soapclient.js</a></li>
            <li><a href="../lib/swiper.js.html">lib/swiper.js</a></li>
            <li><a href="../providers/services/twitter-provider.js.html">providers/services/twitter-provider.js</a></li>
            <li><a href="../suprema/suprema.controller.js.html">suprema/suprema.controller.js</a></li>
          </ul>
          <div class="scrollspy">
            <ul class="nav nav-list bs-docs-sidenav affix-top">
              <li><a href="#select"><i class="alert alert-success"></i><span>select</span></a>
              </li>
              <li><a href="#indexOfSlide"><i class="alert alert-info"></i><span>indexOfSlide</span></a>
              </li>
              <li><a href="#getRawNode"><i class="alert alert-info"></i><span>getRawNode</span></a>
              </li>
              <li><a href="#parseStyle"><i class="alert alert-info"></i><span>parseStyle</span></a>
              </li>
              <li><a href="#offsetParent"><i class="alert alert-info"></i><span>offsetParent</span></a>
              </li>
              <li><a href="#scrollbarWidth"><i class="alert alert-info"></i><span>scrollbarWidth</span></a>
              </li>
              <li><a href="#scrollbarPadding"><i class="alert alert-info"></i><span>scrollbarPadding</span></a>
              </li>
              <li><a href="#isScrollable"><i class="alert alert-info"></i><span>isScrollable</span></a>
              </li>
              <li><a href="#scrollParent"><i class="alert alert-info"></i><span>scrollParent</span></a>
              </li>
              <li><a href="#position"><i class="alert alert-info"></i><span>position</span></a>
              </li>
              <li><a href="#offset"><i class="alert alert-info"></i><span>offset</span></a>
              </li>
              <li><a href="#viewportOffset"><i class="alert alert-info"></i><span>viewportOffset</span></a>
              </li>
              <li><a href="#parsePlacement"><i class="alert alert-info"></i><span>parsePlacement</span></a>
              </li>
              <li><a href="#positionElements"><i class="alert alert-info"></i><span>positionElements</span></a>
              </li>
              <li><a href="#adjustTop"><i class="alert alert-info"></i><span>adjustTop</span></a>
              </li>
              <li><a href="#positionArrow"><i class="alert alert-info"></i><span>positionArrow</span></a>
              </li>
              <li><a href="#if"><i class="alert alert-info"></i><span>if</span></a>
              </li>
              <li><a href="#if"><i class="alert alert-info"></i><span>if</span></a>
              </li>
              <li><a href="#options"><i class="alert alert-info"></i><span>options</span></a>
              </li>
              <li><a href="#setTriggers"><i class="alert alert-info"></i><span>setTriggers</span></a>
              </li>
              <li><a href="#snake_case"><i class="alert alert-info"></i><span>snake_case</span></a>
              </li>
              <li><a href="#$get"><i class="alert alert-success"></i><span>$get</span></a>
              </li>
              <li><a href="#getTriggers"><i class="alert alert-info"></i><span>getTriggers</span></a>
              </li>
              <li><a href="#prepareTooltip"><i class="alert alert-info"></i><span>prepareTooltip</span></a>
              </li>
              <li><a href="#if"><i class="alert alert-info"></i><span>if</span></a>
              </li>
            </ul>
          </div>
        </div>
        <div class="span9">
          <div class="description"><p>angular-ui-bootstrap<br /><a href="http://angular-ui.github.io/bootstrap/">http://angular-ui.github.io/bootstrap/</a></p><p>Version: 2.1.1 - 2016-08-20<br />License: MIT</p></div>
          <pre><code class="language-javascript">ngular.module(&quot;ui.bootstrap&quot;, [&quot;ui.bootstrap.tpls&quot;, &quot;ui.bootstrap.collapse&quot;,&quot;ui.bootstrap.tabindex&quot;,&quot;ui.bootstrap.accordion&quot;,&quot;ui.bootstrap.alert&quot;,&quot;ui.bootstrap.buttons&quot;,&quot;ui.bootstrap.carousel&quot;,&quot;ui.bootstrap.dateparser&quot;,&quot;ui.bootstrap.isClass&quot;,&quot;ui.bootstrap.datepicker&quot;,&quot;ui.bootstrap.position&quot;,&quot;ui.bootstrap.datepickerPopup&quot;,&quot;ui.bootstrap.debounce&quot;,&quot;ui.bootstrap.dropdown&quot;,&quot;ui.bootstrap.stackedMap&quot;,&quot;ui.bootstrap.modal&quot;,&quot;ui.bootstrap.paging&quot;,&quot;ui.bootstrap.pager&quot;,&quot;ui.bootstrap.pagination&quot;,&quot;ui.bootstrap.tooltip&quot;,&quot;ui.bootstrap.popover&quot;,&quot;ui.bootstrap.progressbar&quot;,&quot;ui.bootstrap.rating&quot;,&quot;ui.bootstrap.tabs&quot;,&quot;ui.bootstrap.timepicker&quot;,&quot;ui.bootstrap.typeahead&quot;]);
angular.module(&quot;ui.bootstrap.tpls&quot;, [&quot;uib/template/accordion/accordion-group.html&quot;,&quot;uib/template/accordion/accordion.html&quot;,&quot;uib/template/alert/alert.html&quot;,&quot;uib/template/carousel/carousel.html&quot;,&quot;uib/template/carousel/slide.html&quot;,&quot;uib/template/datepicker/datepicker.html&quot;,&quot;uib/template/datepicker/day.html&quot;,&quot;uib/template/datepicker/month.html&quot;,&quot;uib/template/datepicker/year.html&quot;,&quot;uib/template/datepickerPopup/popup.html&quot;,&quot;uib/template/modal/window.html&quot;,&quot;uib/template/pager/pager.html&quot;,&quot;uib/template/pagination/pagination.html&quot;,&quot;uib/template/tooltip/tooltip-html-popup.html&quot;,&quot;uib/template/tooltip/tooltip-popup.html&quot;,&quot;uib/template/tooltip/tooltip-template-popup.html&quot;,&quot;uib/template/popover/popover-html.html&quot;,&quot;uib/template/popover/popover-template.html&quot;,&quot;uib/template/popover/popover.html&quot;,&quot;uib/template/progressbar/bar.html&quot;,&quot;uib/template/progressbar/progress.html&quot;,&quot;uib/template/progressbar/progressbar.html&quot;,&quot;uib/template/rating/rating.html&quot;,&quot;uib/template/tabs/tab.html&quot;,&quot;uib/template/tabs/tabset.html&quot;,&quot;uib/template/timepicker/timepicker.html&quot;,&quot;uib/template/typeahead/typeahead-match.html&quot;,&quot;uib/template/typeahead/typeahead-popup.html&quot;]);
angular.module('ui.bootstrap.collapse', [])

  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        var expandingExpr = $parse(attrs.expanding),
          expandedExpr = $parse(attrs.expanded),
          collapsingExpr = $parse(attrs.collapsing),
          collapsedExpr = $parse(attrs.collapsed),
          horizontal = false,
          css = {},
          cssTo = {};

        init();

        function init() {
          horizontal = !!('horizontal' in attrs);
          if (horizontal) {
            css = {
              width: ''
            };
            cssTo = {width: '0'};
          } else {
            css = {
              height: ''
            };
            cssTo = {height: '0'};
          }
          if (!scope.$eval(attrs.uibCollapse)) {
            element.addClass('in')
              .addClass('collapse')
              .attr('aria-expanded', true)
              .attr('aria-hidden', false)
              .css(css);
          }
        }

        function getScrollFromElement(element) {
          if (horizontal) {
            return {width: ''};
          }
          return {height: ''};
        }

        function expand() {
          if (element.hasClass('collapse') &amp;&amp; element.hasClass('in')) {
            return;
          }

          $q.resolve(expandingExpr(scope))
            .then(function() {
              element.removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', true)
                .attr('aria-hidden', false);

              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  css: {
                    overflow: 'hidden'
                  },
                  to: getScrollFromElement(element[0])
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {
                  css: {
                    overflow: 'hidden'
                  },
                  to: getScrollFromElement(element[0])
                }).then(expandDone);
              }
            });
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse')
            .css(css);
          expandedExpr(scope);
        }

        function collapse() {
          if (!element.hasClass('collapse') &amp;&amp; !element.hasClass('in')) {
            return collapseDone();
          }

          $q.resolve(collapsingExpr(scope))
            .then(function() {
              element
              // IMPORTANT: The width must be set before adding &quot;collapsing&quot; class.
              // Otherwise, the browser attempts to animate from width 0 (in
              // collapsing class) to the given width here.
                .css(getScrollFromElement(element[0]))
                // initially all panel collapse have the collapse class, this removal
                // prevents the animation from jumping to collapsed state
                .removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', false)
                .attr('aria-hidden', true);

              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: cssTo
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {
                  to: cssTo
                }).then(collapseDone);
              }
            });
        }

        function collapseDone() {
          element.css(cssTo); // Required so that collapse works when animation is disabled
          element.removeClass('collapsing')
            .addClass('collapse');
          collapsedExpr(scope);
        }

        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module('ui.bootstrap.tabindex', [])

.directive('uibTabindexToggle', function() {
  return {
    restrict: 'A',
    link: function(scope, elem, attrs) {
      attrs.$observe('disabled', function(disabled) {
        attrs.$set('tabindex', disabled ? -1 : null);
      });
    }
  };
});

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])

.constant('uibAccordionConfig', {
  closeOthers: true
})

.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ?
      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if (closeOthers) {
      angular.forEach(this.groups, function(group) {
        if (group !== openGroup) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function(event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
    }
  };
}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('uibAccordion', function() {
  return {
    controller: 'UibAccordionController',
    controllerAs: 'accordion',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/accordion/accordion.html';
    }
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('uibAccordionGroup', function() {
  return {
    require: '^uibAccordion',         // We need this directive to be inside an accordion
    transclude: true,              // It transcludes the contents of the directive into the template
    restrict: 'A',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
    },
    scope: {
      heading: '@',               // Interpolate the heading attribute onto this scope
      panelClass: '@?',           // Ditto with panelClass
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      element.addClass('panel');
      accordionCtrl.addGroup(scope);

      scope.openClass = attrs.openClass || 'panel-open';
      scope.panelClass = attrs.panelClass || 'panel-default';
      scope.$watch('isOpen', function(value) {
        element.toggleClass(scope.openClass, !!value);
        if (value) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function($event) {
        if (!scope.isDisabled) {
          if (!$event || $event.which === 32) {
            scope.isOpen = !scope.isOpen;
          }
        }
      };

      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      scope.headingId = id + '-tab';
      scope.panelId = id + '-panel';
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
.directive('uibAccordionHeading', function() {
  return {
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
.directive('uibAccordionTransclude', function() {
  return {
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, controller) {
      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
        if (heading) {
          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
          elem.html('');
          elem.append(heading);
        }
      });
    }
  };

  function getHeaderSelectors() {
      return 'uib-accordion-header,' +
          'data-uib-accordion-header,' +
          'x-uib-accordion-header,' +
          'uib\\:accordion-header,' +
          '[uib-accordion-header],' +
          '[data-uib-accordion-header],' +
          '[x-uib-accordion-header]';
  }
});

angular.module('ui.bootstrap.alert', [])

.controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function($scope, $element, $attrs, $interpolate, $timeout) {
  $scope.closeable = !!$attrs.close;
  $element.addClass('alert');
  $attrs.$set('role', 'alert');
  if ($scope.closeable) {
    $element.addClass('alert-dismissible');
  }

  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

  if (dismissOnTimeout) {
    $timeout(function() {
      $scope.close();
    }, parseInt(dismissOnTimeout, 10));
  }
}])

.directive('uibAlert', function() {
  return {
    controller: 'UibAlertController',
    controllerAs: 'alert',
    restrict: 'A',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/alert/alert.html';
    },
    transclude: true,
    scope: {
      close: '&amp;'
    }
  };
});

angular.module('ui.bootstrap.buttons', [])

.constant('uibButtonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('uibBtnRadio', ['$parse', function($parse) {
  return {
    require: ['uibBtnRadio', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'buttons',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      var uncheckableExpr = $parse(attrs.uibUncheckable);

      element.find('input').css({display: 'none'});

      //model -&gt; UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
      };

      //ui-&gt;model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
            ngModelCtrl.$render();
          });
        }
      });

      if (attrs.uibUncheckable) {
        scope.$watch(uncheckableExpr, function(uncheckable) {
          attrs.$set('uncheckable', uncheckable ? '' : undefined);
        });
      }
    }
  };
}])

.directive('uibBtnCheckbox', function() {
  return {
    require: ['uibBtnCheckbox', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'button',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find('input').css({display: 'none'});

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attribute, defaultValue) {
        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
      }

      //model -&gt; UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui-&gt;model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        scope.$apply(function() {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

angular.module('ui.bootstrap.carousel', [])

.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    SLIDE_DIRECTION = 'uib-slideDirection',
    currentIndex = $scope.active,
    currentInterval, isPlaying, bufferedTransitions = [];

  var destroyed = false;
  $element.addClass('carousel');

  self.addSlide = function(slide, element) {
    slides.push({
      slide: slide,
      element: element
    });
    slides.sort(function(a, b) {
      return +a.slide.index - +b.slide.index;
    });
    //if this is the first slide or the slide is set to active, select it
    if (slide.index === $scope.active || slides.length === 1 &amp;&amp; !angular.isNumber($scope.active)) {
      if ($scope.$currentTransition) {
        $scope.$currentTransition = null;
      }

      currentIndex = slide.index;
      $scope.active = slide.index;
      setActive(currentIndex);
      self.select(slides[findSlideIndex(slide)]);
      if (slides.length === 1) {
        $scope.play();
      }
    }
  };

  self.getCurrentIndex = function() {
    for (var i = 0; i &lt; slides.length; i++) {
      if (slides[i].slide.index === currentIndex) {
        return i;
      }
    }
  };

  self.next = $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    if (newIndex === 0 &amp;&amp; $scope.noWrap()) {
      $scope.pause();
      return;
    }

    return self.select(slides[newIndex], 'next');
  };

  self.prev = $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 &lt; 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    if ($scope.noWrap() &amp;&amp; newIndex === slides.length - 1) {
      $scope.pause();
      return;
    }

    return self.select(slides[newIndex], 'prev');
  };

  self.removeSlide = function(slide) {
    var index = findSlideIndex(slide);

    var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
    if (bufferedIndex !== -1) {
      bufferedTransitions.splice(bufferedIndex, 1);
    }

    //get the index of the slide inside the carousel
    slides.splice(index, 1);
    if (slides.length &gt; 0 &amp;&amp; currentIndex === index) {
      if (index &gt;= slides.length) {
        currentIndex = slides.length - 1;
        $scope.active = currentIndex;
        setActive(currentIndex);
        self.select(slides[slides.length - 1]);
      } else {
        currentIndex = index;
        $scope.active = currentIndex;
        setActive(currentIndex);
        self.select(slides[index]);
      }
    } else if (currentIndex &gt; index) {
      currentIndex--;
      $scope.active = currentIndex;
    }

    //clean the active value when no more slide
    if (slides.length === 0) {
      currentIndex = null;
      $scope.active = null;
      clearBufferedTransitions();
    }
  };</code></pre>
          <section id="select">
            <h1>select</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-success radius ctx-type">property</div><span>&nbsp;</span><span>self.select</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>direction: &quot;prev&quot; or &quot;next&quot;</p></div>
          <pre><code class="language-javascript">self.select = $scope.select = function(nextSlide, direction) {
  var nextIndex = findSlideIndex(nextSlide.slide);
  //Decide direction if it's not given
  if (direction === undefined) {
    direction = nextIndex &gt; self.getCurrentIndex() ? 'next' : 'prev';
  }
  //Prevent this user-triggered transition from occurring if there is already one in progress
  if (nextSlide.slide.index !== currentIndex &amp;&amp;
    !$scope.$currentTransition) {
    goNext(nextSlide.slide, nextIndex, direction);
  } else if (nextSlide &amp;&amp; nextSlide.slide.index !== currentIndex &amp;&amp; $scope.$currentTransition) {
    bufferedTransitions.push(slides[nextIndex]);
  }
};</code></pre>
          <section id="indexOfSlide">
            <h1>indexOfSlide</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>$scope.indexOfSlide()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Allow outside people to call indexOf on slides array</p></div>
          <pre><code class="language-javascript">$scope.indexOfSlide = function(slide) {
  return +slide.slide.index;
};

$scope.isActive = function(slide) {
  return $scope.active === slide.slide.index;
};

$scope.isPrevDisabled = function() {
  return $scope.active === 0 &amp;&amp; $scope.noWrap();
};

$scope.isNextDisabled = function() {
  return $scope.active === slides.length - 1 &amp;&amp; $scope.noWrap();
};

$scope.pause = function() {
  if (!$scope.noPause) {
    isPlaying = false;
    resetTimer();
  }
};

$scope.play = function() {
  if (!isPlaying) {
    isPlaying = true;
    restartTimer();
  }
};

$element.on('mouseenter', $scope.pause);
$element.on('mouseleave', $scope.play);

$scope.$on('$destroy', function() {
  destroyed = true;
  resetTimer();
});

$scope.$watch('noTransition', function(noTransition) {
  $animate.enabled($element, !noTransition);
});

$scope.$watch('interval', restartTimer);

$scope.$watchCollection('slides', resetTransition);

$scope.$watch('active', function(index) {
  if (angular.isNumber(index) &amp;&amp; currentIndex !== index) {
    for (var i = 0; i &lt; slides.length; i++) {
      if (slides[i].slide.index === index) {
        index = i;
        break;
      }
    }

    var slide = slides[index];
    if (slide) {
      setActive(index);
      self.select(slides[index]);
      currentIndex = index;
    }
  }
});

function clearBufferedTransitions() {
  while (bufferedTransitions.length) {
    bufferedTransitions.shift();
  }
}

function getSlideByIndex(index) {
  for (var i = 0, l = slides.length; i &lt; l; ++i) {
    if (slides[i].index === index) {
      return slides[i];
    }
  }
}

function setActive(index) {
  for (var i = 0; i &lt; slides.length; i++) {
    slides[i].slide.active = i === index;
  }
}

function goNext(slide, index, direction) {
  if (destroyed) {
    return;
  }

  angular.extend(slide, {direction: direction});
  angular.extend(slides[currentIndex].slide || {}, {direction: direction});
  if ($animate.enabled($element) &amp;&amp; !$scope.$currentTransition &amp;&amp;
    slides[index].element &amp;&amp; self.slides.length &gt; 1) {
    slides[index].element.data(SLIDE_DIRECTION, slide.direction);
    var currentIdx = self.getCurrentIndex();

    if (angular.isNumber(currentIdx) &amp;&amp; slides[currentIdx].element) {
      slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
    }

    $scope.$currentTransition = true;
    $animate.on('addClass', slides[index].element, function(element, phase) {
      if (phase === 'close') {
        $scope.$currentTransition = null;
        $animate.off('addClass', element);
        if (bufferedTransitions.length) {
          var nextSlide = bufferedTransitions.pop().slide;
          var nextIndex = nextSlide.index;
          var nextDirection = nextIndex &gt; self.getCurrentIndex() ? 'next' : 'prev';
          clearBufferedTransitions();

          goNext(nextSlide, nextIndex, nextDirection);
        }
      }
    });
  }

  $scope.active = slide.index;
  currentIndex = slide.index;
  setActive(index);

  //every time you change slides, reset the timer
  restartTimer();
}

function findSlideIndex(slide) {
  for (var i = 0; i &lt; slides.length; i++) {
    if (slides[i].slide === slide) {
      return i;
    }
  }
}

function resetTimer() {
  if (currentInterval) {
    $interval.cancel(currentInterval);
    currentInterval = null;
  }
}

function resetTransition(slides) {
  if (!slides.length) {
    $scope.$currentTransition = null;
    clearBufferedTransitions();
  }
}

function restartTimer() {
  resetTimer();
  var interval = +$scope.interval;
  if (!isNaN(interval) &amp;&amp; interval &gt; 0) {
    currentInterval = $interval(timerFn, interval);
  }
}

function timerFn() {
  var interval = +$scope.interval;
  if (isPlaying &amp;&amp; !isNaN(interval) &amp;&amp; interval &gt; 0 &amp;&amp; slides.length) {
    $scope.next();
  } else {
    $scope.pause();
  }
}
}])

.directive('uibCarousel', function() {
return {
  transclude: true,
  controller: 'UibCarouselController',
  controllerAs: 'carousel',
  restrict: 'A',
  templateUrl: function(element, attrs) {
    return attrs.templateUrl || 'uib/template/carousel/carousel.html';
  },
  scope: {
    active: '=',
    interval: '=',
    noTransition: '=',
    noPause: '=',
    noWrap: '&amp;'
  }
};
})

.directive('uibSlide', ['$animate', function($animate) {
return {
  require: '^uibCarousel',
  restrict: 'A',
  transclude: true,
  templateUrl: function(element, attrs) {
    return attrs.templateUrl || 'uib/template/carousel/slide.html';
  },
  scope: {
    actual: '=?',
    index: '=?'
  },
  link: function (scope, element, attrs, carouselCtrl) {
    element.addClass('item');
    carouselCtrl.addSlide(scope, element);
    //when the scope is destroyed then remove the slide from the current slides array
    scope.$on('$destroy', function() {
      carouselCtrl.removeSlide(scope);
    });

    scope.$watch('active', function(active) {
      $animate[active ? 'addClass' : 'removeClass'](element, 'active');
    });
  }
};
}])

.animation('.item', ['$animateCss',
function($animateCss) {
var SLIDE_DIRECTION = 'uib-slideDirection';

function removeClass(element, className, callback) {
  element.removeClass(className);
  if (callback) {
    callback();
  }
}

return {
  beforeAddClass: function(element, className, done) {
    if (className === 'active') {
      var stopped = false;
      var direction = element.data(SLIDE_DIRECTION);
      var directionClass = direction === 'next' ? 'left' : 'right';
      var removeClassFn = removeClass.bind(this, element,
        directionClass + ' ' + direction, done);
      element.addClass(direction);

      $animateCss(element, {addClass: directionClass})
        .start()
        .done(removeClassFn);

      return function() {
        stopped = true;
      };
    }
    done();
  },
  beforeRemoveClass: function (element, className, done) {
    if (className === 'active') {
      var stopped = false;
      var direction = element.data(SLIDE_DIRECTION);
      var directionClass = direction === 'next' ? 'left' : 'right';
      var removeClassFn = removeClass.bind(this, element, directionClass, done);

      $animateCss(element, {addClass: directionClass})
        .start()
        .done(removeClassFn);

      return function() {
        stopped = true;
      };
    }
    done();
  }
};
}]);

angular.module('ui.bootstrap.dateparser', [])

.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
// Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

var localeId;
var formatCodeToRegex;

this.init = function() {
  localeId = $locale.id;

  this.parsers = {};
  this.formatters = {};

  formatCodeToRegex = [
    {
      key: 'yyyy',
      regex: '\\d{4}',
      apply: function(value) { this.year = +value; },
      formatter: function(date) {
        var _date = new Date();
        _date.setFullYear(Math.abs(date.getFullYear()));
        return dateFilter(_date, 'yyyy');
      }
    },
    {
      key: 'yy',
      regex: '\\d{2}',
      apply: function(value) { value = +value; this.year = value &lt; 69 ? value + 2000 : value + 1900; },
      formatter: function(date) {
        var _date = new Date();
        _date.setFullYear(Math.abs(date.getFullYear()));
        return dateFilter(_date, 'yy');
      }
    },
    {
      key: 'y',
      regex: '\\d{1,4}',
      apply: function(value) { this.year = +value; },
      formatter: function(date) {
        var _date = new Date();
        _date.setFullYear(Math.abs(date.getFullYear()));
        return dateFilter(_date, 'y');
      }
    },
    {
      key: 'M!',
      regex: '0?[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; },
      formatter: function(date) {
        var value = date.getMonth();
        if (/^[0-9]$/.test(value)) {
          return dateFilter(date, 'MM');
        }

        return dateFilter(date, 'M');
      }
    },
    {
      key: 'MMMM',
      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
      formatter: function(date) { return dateFilter(date, 'MMMM'); }
    },
    {
      key: 'MMM',
      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
      formatter: function(date) { return dateFilter(date, 'MMM'); }
    },
    {
      key: 'MM',
      regex: '0[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; },
      formatter: function(date) { return dateFilter(date, 'MM'); }
    },
    {
      key: 'M',
      regex: '[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; },
      formatter: function(date) { return dateFilter(date, 'M'); }
    },
    {
      key: 'd!',
      regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; },
      formatter: function(date) {
        var value = date.getDate();
        if (/^[1-9]$/.test(value)) {
          return dateFilter(date, 'dd');
        }

        return dateFilter(date, 'd');
      }
    },
    {
      key: 'dd',
      regex: '[0-2][0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; },
      formatter: function(date) { return dateFilter(date, 'dd'); }
    },
    {
      key: 'd',
      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; },
      formatter: function(date) { return dateFilter(date, 'd'); }
    },
    {
      key: 'EEEE',
      regex: $locale.DATETIME_FORMATS.DAY.join('|'),
      formatter: function(date) { return dateFilter(date, 'EEEE'); }
    },
    {
      key: 'EEE',
      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
      formatter: function(date) { return dateFilter(date, 'EEE'); }
    },
    {
      key: 'HH',
      regex: '(?:0|1)[0-9]|2[0-3]',
      apply: function(value) { this.hours = +value; },
      formatter: function(date) { return dateFilter(date, 'HH'); }
    },
    {
      key: 'hh',
      regex: '0[0-9]|1[0-2]',
      apply: function(value) { this.hours = +value; },
      formatter: function(date) { return dateFilter(date, 'hh'); }
    },
    {
      key: 'H',
      regex: '1?[0-9]|2[0-3]',
      apply: function(value) { this.hours = +value; },
      formatter: function(date) { return dateFilter(date, 'H'); }
    },
    {
      key: 'h',
      regex: '[0-9]|1[0-2]',
      apply: function(value) { this.hours = +value; },
      formatter: function(date) { return dateFilter(date, 'h'); }
    },
    {
      key: 'mm',
      regex: '[0-5][0-9]',
      apply: function(value) { this.minutes = +value; },
      formatter: function(date) { return dateFilter(date, 'mm'); }
    },
    {
      key: 'm',
      regex: '[0-9]|[1-5][0-9]',
      apply: function(value) { this.minutes = +value; },
      formatter: function(date) { return dateFilter(date, 'm'); }
    },
    {
      key: 'sss',
      regex: '[0-9][0-9][0-9]',
      apply: function(value) { this.milliseconds = +value; },
      formatter: function(date) { return dateFilter(date, 'sss'); }
    },
    {
      key: 'ss',
      regex: '[0-5][0-9]',
      apply: function(value) { this.seconds = +value; },
      formatter: function(date) { return dateFilter(date, 'ss'); }
    },
    {
      key: 's',
      regex: '[0-9]|[1-5][0-9]',
      apply: function(value) { this.seconds = +value; },
      formatter: function(date) { return dateFilter(date, 's'); }
    },
    {
      key: 'a',
      regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
      apply: function(value) {
        if (this.hours === 12) {
          this.hours = 0;
        }

        if (value === 'PM') {
          this.hours += 12;
        }
      },
      formatter: function(date) { return dateFilter(date, 'a'); }
    },
    {
      key: 'Z',
      regex: '[+-]\\d{4}',
      apply: function(value) {
        var matches = value.match(/([+-])(\d{2})(\d{2})/),
          sign = matches[1],
          hours = matches[2],
          minutes = matches[3];
        this.hours += toInt(sign + hours);
        this.minutes += toInt(sign + minutes);
      },
      formatter: function(date) {
        return dateFilter(date, 'Z');
      }
    },
    {
      key: 'ww',
      regex: '[0-4][0-9]|5[0-3]',
      formatter: function(date) { return dateFilter(date, 'ww'); }
    },
    {
      key: 'w',
      regex: '[0-9]|[1-4][0-9]|5[0-3]',
      formatter: function(date) { return dateFilter(date, 'w'); }
    },
    {
      key: 'GGGG',
      regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
      formatter: function(date) { return dateFilter(date, 'GGGG'); }
    },
    {
      key: 'GGG',
      regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
      formatter: function(date) { return dateFilter(date, 'GGG'); }
    },
    {
      key: 'GG',
      regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
      formatter: function(date) { return dateFilter(date, 'GG'); }
    },
    {
      key: 'G',
      regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
      formatter: function(date) { return dateFilter(date, 'G'); }
    }
  ];
};

this.init();

function createParser(format) {
  var map = [], regex = format.split('');

  // check for literal values
  var quoteIndex = format.indexOf('\'');
  if (quoteIndex &gt; -1) {
    var inLiteral = false;
    format = format.split('');
    for (var i = quoteIndex; i &lt; format.length; i++) {
      if (inLiteral) {
        if (format[i] === '\'') {
          if (i + 1 &lt; format.length &amp;&amp; format[i+1] === '\'') { // escaped single quote
            format[i+1] = '$';
            regex[i+1] = '';
          } else { // end of literal
            regex[i] = '';
            inLiteral = false;
          }
        }
        format[i] = '$';
      } else {
        if (format[i] === '\'') { // start of literal
          format[i] = '$';
          regex[i] = '';
          inLiteral = true;
        }
      }
    }

    format = format.join('');
  }

  angular.forEach(formatCodeToRegex, function(data) {
    var index = format.indexOf(data.key);

    if (index &gt; -1) {
      format = format.split('');

      regex[index] = '(' + data.regex + ')';
      format[index] = '$'; // Custom symbol to define consumed part of format
      for (var i = index + 1, n = index + data.key.length; i &lt; n; i++) {
        regex[i] = '';
        format[i] = '$';
      }
      format = format.join('');

      map.push({
        index: index,
        key: data.key,
        apply: data.apply,
        matcher: data.regex
      });
    }
  });

  return {
    regex: new RegExp('^' + regex.join('') + '$'),
    map: orderByFilter(map, 'index')
  };
}

function createFormatter(format) {
  var formatters = [];
  var i = 0;
  var formatter, literalIdx;
  while (i &lt; format.length) {
    if (angular.isNumber(literalIdx)) {
      if (format.charAt(i) === '\'') {
        if (i + 1 &gt;= format.length || format.charAt(i + 1) !== '\'') {
          formatters.push(constructLiteralFormatter(format, literalIdx, i));
          literalIdx = null;
        }
      } else if (i === format.length) {
        while (literalIdx &lt; format.length) {
          formatter = constructFormatterFromIdx(format, literalIdx);
          formatters.push(formatter);
          literalIdx = formatter.endIdx;
        }
      }

      i++;
      continue;
    }

    if (format.charAt(i) === '\'') {
      literalIdx = i;
      i++;
      continue;
    }

    formatter = constructFormatterFromIdx(format, i);

    formatters.push(formatter.parser);
    i = formatter.endIdx;
  }

  return formatters;
}

function constructLiteralFormatter(format, literalIdx, endIdx) {
  return function() {
    return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
  };
}

function constructFormatterFromIdx(format, i) {
  var currentPosStr = format.substr(i);
  for (var j = 0; j &lt; formatCodeToRegex.length; j++) {
    if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
      var data = formatCodeToRegex[j];
      return {
        endIdx: i + data.key.length,
        parser: data.formatter
      };
    }
  }

  return {
    endIdx: i + 1,
    parser: function() {
      return currentPosStr.charAt(0);
    }
  };
}

this.filter = function(date, format) {
  if (!angular.isDate(date) || isNaN(date) || !format) {
    return '';
  }

  format = $locale.DATETIME_FORMATS[format] || format;

  if ($locale.id !== localeId) {
    this.init();
  }

  if (!this.formatters[format]) {
    this.formatters[format] = createFormatter(format);
  }

  var formatters = this.formatters[format];

  return formatters.reduce(function(str, formatter) {
    return str + formatter(date);
  }, '');
};

this.parse = function(input, format, baseDate) {
  if (!angular.isString(input) || !format) {
    return input;
  }

  format = $locale.DATETIME_FORMATS[format] || format;
  format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&amp;');

  if ($locale.id !== localeId) {
    this.init();
  }

  if (!this.parsers[format]) {
    this.parsers[format] = createParser(format, 'apply');
  }

  var parser = this.parsers[format],
      regex = parser.regex,
      map = parser.map,
      results = input.match(regex),
      tzOffset = false;
  if (results &amp;&amp; results.length) {
    var fields, dt;
    if (angular.isDate(baseDate) &amp;&amp; !isNaN(baseDate.getTime())) {
      fields = {
        year: baseDate.getFullYear(),
        month: baseDate.getMonth(),
        date: baseDate.getDate(),
        hours: baseDate.getHours(),
        minutes: baseDate.getMinutes(),
        seconds: baseDate.getSeconds(),
        milliseconds: baseDate.getMilliseconds()
      };
    } else {
      if (baseDate) {
        $log.warn('dateparser:', 'baseDate is not a valid date');
      }
      fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
    }

    for (var i = 1, n = results.length; i &lt; n; i++) {
      var mapper = map[i - 1];
      if (mapper.matcher === 'Z') {
        tzOffset = true;
      }

      if (mapper.apply) {
        mapper.apply.call(fields, results[i]);
      }
    }

    var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
      Date.prototype.setFullYear;
    var timesetter = tzOffset ? Date.prototype.setUTCHours :
      Date.prototype.setHours;

    if (isValid(fields.year, fields.month, fields.date)) {
      if (angular.isDate(baseDate) &amp;&amp; !isNaN(baseDate.getTime()) &amp;&amp; !tzOffset) {
        dt = new Date(baseDate);
        datesetter.call(dt, fields.year, fields.month, fields.date);
        timesetter.call(dt, fields.hours, fields.minutes,
          fields.seconds, fields.milliseconds);
      } else {
        dt = new Date(0);
        datesetter.call(dt, fields.year, fields.month, fields.date);
        timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
          fields.seconds || 0, fields.milliseconds || 0);
      }
    }

    return dt;
  }
};

// Check if date is valid for specific month (and year for February).
// Month: 0 = Jan, 1 = Feb, etc
function isValid(year, month, date) {
  if (date &lt; 1) {
    return false;
  }

  if (month === 1 &amp;&amp; date &gt; 28) {
    return date === 29 &amp;&amp; (year % 4 === 0 &amp;&amp; year % 100 !== 0 || year % 400 === 0);
  }

  if (month === 3 || month === 5 || month === 8 || month === 10) {
    return date &lt; 31;
  }

  return true;
}

function toInt(str) {
  return parseInt(str, 10);
}

this.toTimezone = toTimezone;
this.fromTimezone = fromTimezone;
this.timezoneToOffset = timezoneToOffset;
this.addDateMinutes = addDateMinutes;
this.convertTimezoneToLocal = convertTimezoneToLocal;

function toTimezone(date, timezone) {
  return date &amp;&amp; timezone ? convertTimezoneToLocal(date, timezone) : date;
}

function fromTimezone(date, timezone) {
  return date &amp;&amp; timezone ? convertTimezoneToLocal(date, timezone, true) : date;
}

//https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, '');
  var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}

function addDateMinutes(date, minutes) {
  date = new Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  return date;
}

function convertTimezoneToLocal(date, timezone, reverse) {
  reverse = reverse ? -1 : 1;
  var dateTimezoneOffset = date.getTimezoneOffset();
  var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
}
}]);

// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
// at most one element.
angular.module('ui.bootstrap.isClass', [])
.directive('uibIsClass', [
       '$animate',
function ($animate) {
//                    11111111          22222222
var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
//                    11111111           22222222
var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

var dataPerTracked = {};

return {
  restrict: 'A',
  compile: function(tElement, tAttrs) {
    var linkedScopes = [];
    var instances = [];
    var expToData = {};
    var lastActivated = null;
    var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
    var onExp = onExpMatches[2];
    var expsStr = onExpMatches[1];
    var exps = expsStr.split(',');

    return linkFn;

    function linkFn(scope, element, attrs) {
      linkedScopes.push(scope);
      instances.push({
        scope: scope,
        element: element
      });

      exps.forEach(function(exp, k) {
        addForExp(exp, scope);
      });

      scope.$on('$destroy', removeScope);
    }

    function addForExp(exp, scope) {
      var matches = exp.match(IS_REGEXP);
      var clazz = scope.$eval(matches[1]);
      var compareWithExp = matches[2];
      var data = expToData[exp];
      if (!data) {
        var watchFn = function(compareWithVal) {
          var newActivated = null;
          instances.some(function(instance) {
            var thisVal = instance.scope.$eval(onExp);
            if (thisVal === compareWithVal) {
              newActivated = instance;
              return true;
            }
          });
          if (data.lastActivated !== newActivated) {
            if (data.lastActivated) {
              $animate.removeClass(data.lastActivated.element, clazz);
            }
            if (newActivated) {
              $animate.addClass(newActivated.element, clazz);
            }
            data.lastActivated = newActivated;
          }
        };
        expToData[exp] = data = {
          lastActivated: null,
          scope: scope,
          watchFn: watchFn,
          compareWithExp: compareWithExp,
          watcher: scope.$watch(compareWithExp, watchFn)
        };
      }
      data.watchFn(scope.$eval(compareWithExp));
    }

    function removeScope(e) {
      var removedScope = e.targetScope;
      var index = linkedScopes.indexOf(removedScope);
      linkedScopes.splice(index, 1);
      instances.splice(index, 1);
      if (linkedScopes.length) {
        var newWatchScope = linkedScopes[0];
        angular.forEach(expToData, function(data) {
          if (data.scope === removedScope) {
            data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
            data.scope = newWatchScope;
          }
        });
      } else {
        expToData = {};
      }
    }
  }
};
}]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])

.value('$datepickerSuppressError', false)

.value('$datepickerLiteralWarning', true)

.constant('uibDatepickerConfig', {
datepickerMode: 'day',
formatDay: 'dd',
formatMonth: 'MMMM',
formatYear: 'yyyy',
formatDayHeader: 'EEE',
formatDayTitle: 'MMMM yyyy',
formatMonthTitle: 'yyyy',
maxDate: null,
maxMode: 'year',
minDate: null,
minMode: 'day',
monthColumns: 3,
ngModelOptions: {},
shortcutPropagation: false,
showWeeks: true,
yearColumns: 5,
yearRows: 4
})

.controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',
function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
var self = this,
    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;
    ngModelOptions = {},
    watchListeners = [];

$element.addClass('uib-datepicker');
$attrs.$set('role', 'application');

if (!$scope.datepickerOptions) {
  $scope.datepickerOptions = {};
}

// Modes chain
this.modes = ['day', 'month', 'year'];

[
  'customClass',
  'dateDisabled',
  'datepickerMode',
  'formatDay',
  'formatDayHeader',
  'formatDayTitle',
  'formatMonth',
  'formatMonthTitle',
  'formatYear',
  'maxDate',
  'maxMode',
  'minDate',
  'minMode',
  'monthColumns',
  'showWeeks',
  'shortcutPropagation',
  'startingDay',
  'yearColumns',
  'yearRows'
].forEach(function(key) {
  switch (key) {
    case 'customClass':
    case 'dateDisabled':
      $scope[key] = $scope.datepickerOptions[key] || angular.noop;
      break;
    case 'datepickerMode':
      $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
        $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
      break;
    case 'formatDay':
    case 'formatDayHeader':
    case 'formatDayTitle':
    case 'formatMonth':
    case 'formatMonthTitle':
    case 'formatYear':
      self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
        $interpolate($scope.datepickerOptions[key])($scope.$parent) :
        datepickerConfig[key];
      break;
    case 'monthColumns':
    case 'showWeeks':
    case 'shortcutPropagation':
    case 'yearColumns':
    case 'yearRows':
      self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
        $scope.datepickerOptions[key] : datepickerConfig[key];
      break;
    case 'startingDay':
      if (angular.isDefined($scope.datepickerOptions.startingDay)) {
        self.startingDay = $scope.datepickerOptions.startingDay;
      } else if (angular.isNumber(datepickerConfig.startingDay)) {
        self.startingDay = datepickerConfig.startingDay;
      } else {
        self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
      }

      break;
    case 'maxDate':
    case 'minDate':
      $scope.$watch('datepickerOptions.' + key, function(value) {
        if (value) {
          if (angular.isDate(value)) {
            self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
          } else {
            if ($datepickerLiteralWarning) {
              $log.warn('Literal date support has been deprecated, please switch to date object usage');
            }

            self[key] = new Date(dateFilter(value, 'medium'));
          }
        } else {
          self[key] = datepickerConfig[key] ?
            dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) :
            null;
        }

        self.refreshView();
      });

      break;
    case 'maxMode':
    case 'minMode':
      if ($scope.datepickerOptions[key]) {
        $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {
          self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
          if (key === 'minMode' &amp;&amp; self.modes.indexOf($scope.datepickerOptions.datepickerMode) &lt; self.modes.indexOf(self[key]) ||
            key === 'maxMode' &amp;&amp; self.modes.indexOf($scope.datepickerOptions.datepickerMode) &gt; self.modes.indexOf(self[key])) {
            $scope.datepickerMode = self[key];
            $scope.datepickerOptions.datepickerMode = self[key];
          }
        });
      } else {
        self[key] = $scope[key] = datepickerConfig[key] || null;
      }

      break;
  }
});

$scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

$scope.disabled = angular.isDefined($attrs.disabled) || false;
if (angular.isDefined($attrs.ngDisabled)) {
  watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
    $scope.disabled = disabled;
    self.refreshView();
  }));
}

$scope.isActive = function(dateObject) {
  if (self.compare(dateObject.date, self.activeDate) === 0) {
    $scope.activeDateId = dateObject.uid;
    return true;
  }
  return false;
};

this.init = function(ngModelCtrl_) {
  ngModelCtrl = ngModelCtrl_;
  ngModelOptions = ngModelCtrl_.$options ||
    $scope.datepickerOptions.ngModelOptions ||
    datepickerConfig.ngModelOptions;
  if ($scope.datepickerOptions.initDate) {
    self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
    $scope.$watch('datepickerOptions.initDate', function(initDate) {
      if (initDate &amp;&amp; (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
        self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
        self.refreshView();
      }
    });
  } else {
    self.activeDate = new Date();
  }

  var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
  this.activeDate = !isNaN(date) ?
    dateParser.fromTimezone(date, ngModelOptions.timezone) :
    dateParser.fromTimezone(new Date(), ngModelOptions.timezone);

  ngModelCtrl.$render = function() {
    self.render();
  };
};

this.render = function() {
  if (ngModelCtrl.$viewValue) {
    var date = new Date(ngModelCtrl.$viewValue),
        isValid = !isNaN(date);

    if (isValid) {
      this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
    } else if (!$datepickerSuppressError) {
      $log.error('Datepicker directive: &quot;ng-model&quot; value must be a Date object');
    }
  }
  this.refreshView();
};

this.refreshView = function() {
  if (this.element) {
    $scope.selectedDt = null;
    this._refreshView();
    if ($scope.activeDt) {
      $scope.activeDateId = $scope.activeDt.uid;
    }

    var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    date = dateParser.fromTimezone(date, ngModelOptions.timezone);
    ngModelCtrl.$setValidity('dateDisabled', !date ||
      this.element &amp;&amp; !this.isDisabled(date));
  }
};

this.createDateObject = function(date, format) {
  var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
  model = dateParser.fromTimezone(model, ngModelOptions.timezone);
  var today = new Date();
  today = dateParser.fromTimezone(today, ngModelOptions.timezone);
  var time = this.compare(date, today);
  var dt = {
    date: date,
    label: dateParser.filter(date, format),
    selected: model &amp;&amp; this.compare(date, model) === 0,
    disabled: this.isDisabled(date),
    past: time &lt; 0,
    current: time === 0,
    future: time &gt; 0,
    customClass: this.customClass(date) || null
  };

  if (model &amp;&amp; this.compare(date, model) === 0) {
    $scope.selectedDt = dt;
  }

  if (self.activeDate &amp;&amp; this.compare(dt.date, self.activeDate) === 0) {
    $scope.activeDt = dt;
  }

  return dt;
};

this.isDisabled = function(date) {
  return $scope.disabled ||
    this.minDate &amp;&amp; this.compare(date, this.minDate) &lt; 0 ||
    this.maxDate &amp;&amp; this.compare(date, this.maxDate) &gt; 0 ||
    $scope.dateDisabled &amp;&amp; $scope.dateDisabled({date: date, mode: $scope.datepickerMode});
};

this.customClass = function(date) {
  return $scope.customClass({date: date, mode: $scope.datepickerMode});
};

// Split array into smaller arrays
this.split = function(arr, size) {
  var arrays = [];
  while (arr.length &gt; 0) {
    arrays.push(arr.splice(0, size));
  }
  return arrays;
};

$scope.select = function(date) {
  if ($scope.datepickerMode === self.minMode) {
    var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
    dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
    ngModelCtrl.$setViewValue(dt);
    ngModelCtrl.$render();
  } else {
    self.activeDate = date;
    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

    $scope.$emit('uib:datepicker.mode');
  }

  $scope.$broadcast('uib:datepicker.focus');
};

$scope.move = function(direction) {
  var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
      month = self.activeDate.getMonth() + direction * (self.step.months || 0);
  self.activeDate.setFullYear(year, month, 1);
  self.refreshView();
};

$scope.toggleMode = function(direction) {
  direction = direction || 1;

  if ($scope.datepickerMode === self.maxMode &amp;&amp; direction === 1 ||
    $scope.datepickerMode === self.minMode &amp;&amp; direction === -1) {
    return;
  }

  setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

  $scope.$emit('uib:datepicker.mode');
};

// Key event mapper
$scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

var focusElement = function() {
  self.element[0].focus();
};

// Listen for focus requests from popup directive
$scope.$on('uib:datepicker.focus', focusElement);

$scope.keydown = function(evt) {
  var key = $scope.keys[evt.which];

  if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
    return;
  }

  evt.preventDefault();
  if (!self.shortcutPropagation) {
    evt.stopPropagation();
  }

  if (key === 'enter' || key === 'space') {
    if (self.isDisabled(self.activeDate)) {
      return; // do nothing
    }
    $scope.select(self.activeDate);
  } else if (evt.ctrlKey &amp;&amp; (key === 'up' || key === 'down')) {
    $scope.toggleMode(key === 'up' ? 1 : -1);
  } else {
    self.handleKeyDown(key, evt);
    self.refreshView();
  }
};

$element.on('keydown', function(evt) {
  $scope.$apply(function() {
    $scope.keydown(evt);
  });
});

$scope.$on('$destroy', function() {
  //Clear all watch listeners on destroy
  while (watchListeners.length) {
    watchListeners.shift()();
  }
});

function setMode(mode) {
  $scope.datepickerMode = mode;
  $scope.datepickerOptions.datepickerMode = mode;
}
}])

.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

this.step = { months: 1 };
this.element = $element;
function getDaysInMonth(year, month) {
  return month === 1 &amp;&amp; year % 4 === 0 &amp;&amp;
    (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
}

this.init = function(ctrl) {
  angular.extend(ctrl, this);
  scope.showWeeks = ctrl.showWeeks;
  ctrl.refreshView();
};

this.getDates = function(startDate, n) {
  var dates = new Array(n), current = new Date(startDate), i = 0, date;
  while (i &lt; n) {
    date = new Date(current);
    dates[i++] = date;
    current.setDate(current.getDate() + 1);
  }
  return dates;
};

this._refreshView = function() {
  var year = this.activeDate.getFullYear(),
    month = this.activeDate.getMonth(),
    firstDayOfMonth = new Date(this.activeDate);

  firstDayOfMonth.setFullYear(year, month, 1);

  var difference = this.startingDay - firstDayOfMonth.getDay(),
    numDisplayedFromPreviousMonth = difference &gt; 0 ?
      7 - difference : - difference,
    firstDate = new Date(firstDayOfMonth);

  if (numDisplayedFromPreviousMonth &gt; 0) {
    firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
  }

  // 42 is the number of days on a six-week calendar
  var days = this.getDates(firstDate, 42);
  for (var i = 0; i &lt; 42; i ++) {
    days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
      secondary: days[i].getMonth() !== month,
      uid: scope.uniqueId + '-' + i
    });
  }

  scope.labels = new Array(7);
  for (var j = 0; j &lt; 7; j++) {
    scope.labels[j] = {
      abbr: dateFilter(days[j].date, this.formatDayHeader),
      full: dateFilter(days[j].date, 'EEEE')
    };
  }

  scope.title = dateFilter(this.activeDate, this.formatDayTitle);
  scope.rows = this.split(days, 7);

  if (scope.showWeeks) {
    scope.weekNumbers = [];
    var thursdayIndex = (4 + 7 - this.startingDay) % 7,
        numWeeks = scope.rows.length;
    for (var curWeek = 0; curWeek &lt; numWeeks; curWeek++) {
      scope.weekNumbers.push(
        getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
    }
  }
};

this.compare = function(date1, date2) {
  var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
  var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
  _date1.setFullYear(date1.getFullYear());
  _date2.setFullYear(date2.getFullYear());
  return _date1 - _date2;
};

function getISO8601WeekNumber(date) {
  var checkDate = new Date(date);
  checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
  var time = checkDate.getTime();
  checkDate.setMonth(0); // Compare with Jan 1
  checkDate.setDate(1);
  return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
}

this.handleKeyDown = function(key, evt) {
  var date = this.activeDate.getDate();

  if (key === 'left') {
    date = date - 1;
  } else if (key === 'up') {
    date = date - 7;
  } else if (key === 'right') {
    date = date + 1;
  } else if (key === 'down') {
    date = date + 7;
  } else if (key === 'pageup' || key === 'pagedown') {
    var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
    this.activeDate.setMonth(month, 1);
    date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
  } else if (key === 'home') {
    date = 1;
  } else if (key === 'end') {
    date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
  }
  this.activeDate.setDate(date);
};
}])

.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
this.step = { years: 1 };
this.element = $element;

this.init = function(ctrl) {
  angular.extend(ctrl, this);
  ctrl.refreshView();
};

this._refreshView = function() {
  var months = new Array(12),
      year = this.activeDate.getFullYear(),
      date;

  for (var i = 0; i &lt; 12; i++) {
    date = new Date(this.activeDate);
    date.setFullYear(year, i, 1);
    months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
      uid: scope.uniqueId + '-' + i
    });
  }

  scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
  scope.rows = this.split(months, this.monthColumns);
  scope.yearHeaderColspan = this.monthColumns &gt; 3 ? this.monthColumns - 2 : 1;
};

this.compare = function(date1, date2) {
  var _date1 = new Date(date1.getFullYear(), date1.getMonth());
  var _date2 = new Date(date2.getFullYear(), date2.getMonth());
  _date1.setFullYear(date1.getFullYear());
  _date2.setFullYear(date2.getFullYear());
  return _date1 - _date2;
};

this.handleKeyDown = function(key, evt) {
  var date = this.activeDate.getMonth();

  if (key === 'left') {
    date = date - 1;
  } else if (key === 'up') {
    date = date - this.monthColumns;
  } else if (key === 'right') {
    date = date + 1;
  } else if (key === 'down') {
    date = date + this.monthColumns;
  } else if (key === 'pageup' || key === 'pagedown') {
    var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
    this.activeDate.setFullYear(year);
  } else if (key === 'home') {
    date = 0;
  } else if (key === 'end') {
    date = 11;
  }
  this.activeDate.setMonth(date);
};
}])

.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
var columns, range;
this.element = $element;

function getStartingYear(year) {
  return parseInt((year - 1) / range, 10) * range + 1;
}

this.yearpickerInit = function() {
  columns = this.yearColumns;
  range = this.yearRows * columns;
  this.step = { years: range };
};

this._refreshView = function() {
  var years = new Array(range), date;

  for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i &lt; range; i++) {
    date = new Date(this.activeDate);
    date.setFullYear(start + i, 0, 1);
    years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
      uid: scope.uniqueId + '-' + i
    });
  }

  scope.title = [years[0].label, years[range - 1].label].join(' - ');
  scope.rows = this.split(years, columns);
  scope.columns = columns;
};

this.compare = function(date1, date2) {
  return date1.getFullYear() - date2.getFullYear();
};

this.handleKeyDown = function(key, evt) {
  var date = this.activeDate.getFullYear();

  if (key === 'left') {
    date = date - 1;
  } else if (key === 'up') {
    date = date - columns;
  } else if (key === 'right') {
    date = date + 1;
  } else if (key === 'down') {
    date = date + columns;
  } else if (key === 'pageup' || key === 'pagedown') {
    date += (key === 'pageup' ? - 1 : 1) * range;
  } else if (key === 'home') {
    date = getStartingYear(this.activeDate.getFullYear());
  } else if (key === 'end') {
    date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
  }
  this.activeDate.setFullYear(date);
};
}])

.directive('uibDatepicker', function() {
return {
  templateUrl: function(element, attrs) {
    return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
  },
  scope: {
    datepickerOptions: '=?'
  },
  require: ['uibDatepicker', '^ngModel'],
  restrict: 'A',
  controller: 'UibDatepickerController',
  controllerAs: 'datepicker',
  link: function(scope, element, attrs, ctrls) {
    var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

    datepickerCtrl.init(ngModelCtrl);
  }
};
})

.directive('uibDaypicker', function() {
return {
  templateUrl: function(element, attrs) {
    return attrs.templateUrl || 'uib/template/datepicker/day.html';
  },
  require: ['^uibDatepicker', 'uibDaypicker'],
  restrict: 'A',
  controller: 'UibDaypickerController',
  link: function(scope, element, attrs, ctrls) {
    var datepickerCtrl = ctrls[0],
      daypickerCtrl = ctrls[1];

    daypickerCtrl.init(datepickerCtrl);
  }
};
})

.directive('uibMonthpicker', function() {
return {
  templateUrl: function(element, attrs) {
    return attrs.templateUrl || 'uib/template/datepicker/month.html';
  },
  require: ['^uibDatepicker', 'uibMonthpicker'],
  restrict: 'A',
  controller: 'UibMonthpickerController',
  link: function(scope, element, attrs, ctrls) {
    var datepickerCtrl = ctrls[0],
      monthpickerCtrl = ctrls[1];

    monthpickerCtrl.init(datepickerCtrl);
  }
};
})

.directive('uibYearpicker', function() {
return {
  templateUrl: function(element, attrs) {
    return attrs.templateUrl || 'uib/template/datepicker/year.html';
  },
  require: ['^uibDatepicker', 'uibYearpicker'],
  restrict: 'A',
  controller: 'UibYearpickerController',
  link: function(scope, element, attrs, ctrls) {
    var ctrl = ctrls[0];
    angular.extend(ctrl, ctrls[1]);
    ctrl.yearpickerInit();

    ctrl.refreshView();
  }
};
});

angular.module('ui.bootstrap.position', [])</code></pre>
          <div class="description"><p>A set of utility methods for working with the DOM.<br />It is meant to be used where we need to absolute-position elements in<br />relation to another element (this is the case for tooltips, popovers,<br />typeahead suggestions etc.).</p></div>
          <pre><code class="language-javascript">.factory('$uibPosition', ['$document', '$window', function($document, $window) {</code></pre>
          <div class="description"><p>Used by scrollbarWidth() function to cache scrollbar&#39;s width.<br />Do not access this variable directly, use scrollbarWidth() instead.</p></div>
          <pre><code class="language-javascript">var SCROLLBAR_WIDTH;</code></pre>
          <div class="description"><p>scrollbar on body and html element in IE and Edge overlay<br />content and should be considered 0 width.</p></div>
          <pre><code class="language-javascript">var BODY_SCROLLBAR_WIDTH;
var OVERFLOW_REGEX = {
  normal: /(auto|scroll)/,
  hidden: /(auto|scroll|hidden)/
};
var PLACEMENT_REGEX = {
  auto: /\s?auto?\s?/i,
  primary: /^(top|bottom|left|right)$/,
  secondary: /^(top|bottom|left|right|center)$/,
  vertical: /^(top|bottom)$/
};
var BODY_REGEX = /(HTML|BODY)/;

return {</code></pre>
          <section id="getRawNode">
            <h1>getRawNode</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>getRawNode()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>elem</td>
                <td>element</td>
                <td><ul>
<li>The element to convert.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides a raw DOM element from a jQuery/jQLite element.</p></div>
          <pre><code class="language-javascript">getRawNode: function(elem) {
  return elem.nodeName ? elem : elem[0] || elem;
},</code></pre>
          <section id="parseStyle">
            <h1>parseStyle</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>parseStyle()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>value</td>
                <td>string</td>
                <td><ul>
<li>The style value to parse.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides a parsed number for a style property.  Strips<br />units and casts invalid numbers to 0.</p></div>
          <pre><code class="language-javascript">parseStyle: function(value) {
  value = parseFloat(value);
  return isFinite(value) ? value : 0;
},</code></pre>
          <section id="offsetParent">
            <h1>offsetParent</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>offsetParent()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>element</td>
                <td>element</td>
                <td><ul>
<li>The element to get the offest parent for.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides the closest positioned ancestor.</p></div>
          <pre><code class="language-javascript">offsetParent: function(elem) {
  elem = this.getRawNode(elem);

  var offsetParent = elem.offsetParent || $document[0].documentElement;

  function isStaticPositioned(el) {
    return ($window.getComputedStyle(el).position || 'static') === 'static';
  }

  while (offsetParent &amp;&amp; offsetParent !== $document[0].documentElement &amp;&amp; isStaticPositioned(offsetParent)) {
    offsetParent = offsetParent.offsetParent;
  }

  return offsetParent || $document[0].documentElement;
},</code></pre>
          <section id="scrollbarWidth">
            <h1>scrollbarWidth</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>scrollbarWidth()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Provides the scrollbar width, concept from TWBS measureScrollbar()<br />function in <a href="https://github.com/twbs/bootstrap/blob/master/js/modal.js">https://github.com/twbs/bootstrap/blob/master/js/modal.js</a><br />In IE and Edge, scollbar on body and html element overlay and should<br />return a width of 0.</p></div>
          <pre><code class="language-javascript">scrollbarWidth: function(isBody) {
  if (isBody) {
    if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
      var bodyElem = $document.find('body');
      bodyElem.addClass('uib-position-body-scrollbar-measure');
      BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
      BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
      bodyElem.removeClass('uib-position-body-scrollbar-measure');
    }
    return BODY_SCROLLBAR_WIDTH;
  }

  if (angular.isUndefined(SCROLLBAR_WIDTH)) {
    var scrollElem = angular.element('&lt;div class=&quot;uib-position-scrollbar-measure&quot;&gt;&lt;/div&gt;');
    $document.find('body').append(scrollElem);
    SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
    SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
    scrollElem.remove();
  }

  return SCROLLBAR_WIDTH;
},</code></pre>
          <section id="scrollbarPadding">
            <h1>scrollbarPadding</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>scrollbarPadding()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Provides the padding required on an element to replace the scrollbar.</p></div>
          <pre><code class="language-javascript">scrollbarPadding: function(elem) {
  elem = this.getRawNode(elem);

  var elemStyle = $window.getComputedStyle(elem);
  var paddingRight = this.parseStyle(elemStyle.paddingRight);
  var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
  var scrollParent = this.scrollParent(elem, false, true);
  var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));

  return {
    scrollbarWidth: scrollbarWidth,
    widthOverflow: scrollParent.scrollWidth &gt; scrollParent.clientWidth,
    right: paddingRight + scrollbarWidth,
    originalRight: paddingRight,
    heightOverflow: scrollParent.scrollHeight &gt; scrollParent.clientHeight,
    bottom: paddingBottom + scrollbarWidth,
    originalBottom: paddingBottom
   };
},</code></pre>
          <section id="isScrollable">
            <h1>isScrollable</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>isScrollable()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>elem</td>
                <td>element</td>
                <td><ul>
<li>The element to check.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>[includeHidden=false]</td>
                <td>boolean</td>
                <td><ul>
<li>Should scroll style of &#39;hidden&#39; be considered,   default is false.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Checks to see if the element is scrollable.</p></div>
          <pre><code class="language-javascript">isScrollable: function(elem, includeHidden) {
  elem = this.getRawNode(elem);

  var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
  var elemStyle = $window.getComputedStyle(elem);
  return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
},</code></pre>
          <section id="scrollParent">
            <h1>scrollParent</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>scrollParent()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>elem</td>
                <td>element</td>
                <td><ul>
<li>The element to find the scroll parent of.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>[includeHidden=false]</td>
                <td>boolean</td>
                <td><ul>
<li>Should scroll style of &#39;hidden&#39; be considered,   default is false.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>[includeSelf=false]</td>
                <td>boolean</td>
                <td><ul>
<li>Should the element being passed be included in the scrollable llokup.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides the closest scrollable ancestor.<br />A port of the jQuery UI scrollParent method:<br /><a href="https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js">https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js</a></p></div>
          <pre><code class="language-javascript">scrollParent: function(elem, includeHidden, includeSelf) {
  elem = this.getRawNode(elem);

  var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
  var documentEl = $document[0].documentElement;
  var elemStyle = $window.getComputedStyle(elem);
  if (includeSelf &amp;&amp; overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
    return elem;
  }
  var excludeStatic = elemStyle.position === 'absolute';
  var scrollParent = elem.parentElement || documentEl;

  if (scrollParent === documentEl || elemStyle.position === 'fixed') {
    return documentEl;
  }

  while (scrollParent.parentElement &amp;&amp; scrollParent !== documentEl) {
    var spStyle = $window.getComputedStyle(scrollParent);
    if (excludeStatic &amp;&amp; spStyle.position !== 'static') {
      excludeStatic = false;
    }

    if (!excludeStatic &amp;&amp; overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
      break;
    }
    scrollParent = scrollParent.parentElement;
  }

  return scrollParent;
},</code></pre>
          <section id="position">
            <h1>position</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>position()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>elem</td>
                <td>element</td>
                <td><ul>
<li>The element to caclulate the position on.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>[includeMargins=false]</td>
                <td>boolean</td>
                <td><ul>
<li>Should margins be accounted for, default is false.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides read-only equivalent of jQuery&#39;s position function:<br /><a href="http://api.jquery.com/position/">http://api.jquery.com/position/</a> - distance to closest positioned<br />ancestor.  Does not account for margins by default like jQuery position.</p></div>
          <pre><code class="language-javascript">position: function(elem, includeMagins) {
  elem = this.getRawNode(elem);

  var elemOffset = this.offset(elem);
  if (includeMagins) {
    var elemStyle = $window.getComputedStyle(elem);
    elemOffset.top -= this.parseStyle(elemStyle.marginTop);
    elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
  }
  var parent = this.offsetParent(elem);
  var parentOffset = {top: 0, left: 0};

  if (parent !== $document[0].documentElement) {
    parentOffset = this.offset(parent);
    parentOffset.top += parent.clientTop - parent.scrollTop;
    parentOffset.left += parent.clientLeft - parent.scrollLeft;
  }

  return {
    width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
    height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
    top: Math.round(elemOffset.top - parentOffset.top),
    left: Math.round(elemOffset.left - parentOffset.left)
  };
},</code></pre>
          <section id="offset">
            <h1>offset</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>offset()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>elem</td>
                <td>element</td>
                <td><ul>
<li>The element to calculate the offset on.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides read-only equivalent of jQuery&#39;s offset function:<br /><a href="http://api.jquery.com/offset/">http://api.jquery.com/offset/</a> - distance to viewport.  Does<br />not account for borders, margins, or padding on the body<br />element.</p></div>
          <pre><code class="language-javascript">offset: function(elem) {
  elem = this.getRawNode(elem);

  var elemBCR = elem.getBoundingClientRect();
  return {
    width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
    height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
    top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
    left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
  };
},</code></pre>
          <section id="viewportOffset">
            <h1>viewportOffset</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>viewportOffset()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>elem</td>
                <td>element</td>
                <td><ul>
<li>The element to get the viewport offset for.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>[useDocument=false]</td>
                <td>boolean</td>
                <td><ul>
<li>Should the viewport be the document element instead of the first scrollable element, default is false.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>[includePadding=true]</td>
                <td>boolean</td>
                <td><ul>
<li>Should the padding on the offset parent element be accounted for, default is true.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides offset distance to the closest scrollable ancestor<br />or viewport.  Accounts for border and scrollbar width.</p><p>Right and bottom dimensions represent the distance to the<br />respective edge of the viewport element.  If the element<br />edge extends beyond the viewport, a negative value will be<br />reported.</p></div>
          <pre><code class="language-javascript">viewportOffset: function(elem, useDocument, includePadding) {
  elem = this.getRawNode(elem);
  includePadding = includePadding !== false ? true : false;

  var elemBCR = elem.getBoundingClientRect();
  var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};

  var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
  var offsetParentBCR = offsetParent.getBoundingClientRect();

  offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
  offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
  if (offsetParent === $document[0].documentElement) {
    offsetBCR.top += $window.pageYOffset;
    offsetBCR.left += $window.pageXOffset;
  }
  offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
  offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

  if (includePadding) {
    var offsetParentStyle = $window.getComputedStyle(offsetParent);
    offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
    offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
    offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
    offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
  }

  return {
    top: Math.round(elemBCR.top - offsetBCR.top),
    bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
    left: Math.round(elemBCR.left - offsetBCR.left),
    right: Math.round(offsetBCR.right - elemBCR.right)
  };
},</code></pre>
          <section id="parsePlacement">
            <h1>parsePlacement</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>parsePlacement()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>placement</td>
                <td>string</td>
                <td><ul>
<li>The placement string to parse.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides an array of placement values parsed from a placement string.<br />Along with the &#39;auto&#39; indicator, supported placement strings are:<br />  <ul><br />    <li>top: element on top, horizontally centered on host element.</li><br />    <li>top-left: element on top, left edge aligned with host element left edge.</li><br />    <li>top-right: element on top, lerightft edge aligned with host element right edge.</li><br />    <li>bottom: element on bottom, horizontally centered on host element.</li><br />    <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li><br />    <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li><br />    <li>left: element on left, vertically centered on host element.</li><br />    <li>left-top: element on left, top edge aligned with host element top edge.</li><br />    <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li><br />    <li>right: element on right, vertically centered on host element.</li><br />    <li>right-top: element on right, top edge aligned with host element top edge.</li><br />    <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li><br />  </ul><br />A placement string with an &#39;auto&#39; indicator is expected to be<br />space separated from the placement, i.e: &#39;auto bottom-left&#39;  If<br />the primary and secondary placement values do not match &#39;top,<br />bottom, left, right&#39; then &#39;top&#39; will be the primary placement and<br />&#39;center&#39; will be the secondary placement.  If &#39;auto&#39; is passed, true<br />will be returned as the 3rd value of the array.</p></div>
          <pre><code class="language-javascript">parsePlacement: function(placement) {
  var autoPlace = PLACEMENT_REGEX.auto.test(placement);
  if (autoPlace) {
    placement = placement.replace(PLACEMENT_REGEX.auto, '');
  }

  placement = placement.split('-');

  placement[0] = placement[0] || 'top';
  if (!PLACEMENT_REGEX.primary.test(placement[0])) {
    placement[0] = 'top';
  }

  placement[1] = placement[1] || 'center';
  if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
    placement[1] = 'center';
  }

  if (autoPlace) {
    placement[2] = true;
  } else {
    placement[2] = false;
  }

  return placement;
},</code></pre>
          <section id="positionElements">
            <h1>positionElements</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>positionElements()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>hostElem</td>
                <td>element</td>
                <td><ul>
<li>The element to position against.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>targetElem</td>
                <td>element</td>
                <td><ul>
<li>The element to position.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>[placement=top]</td>
                <td>string</td>
                <td><ul>
<li>The placement for the targetElem,   default is &#39;top&#39;. &#39;center&#39; is assumed as secondary placement for<br />&#39;top&#39;, &#39;left&#39;, &#39;right&#39;, and &#39;bottom&#39; placements.  Available placements are:<ul><br />  <li>top</li><br />  <li>top-right</li><br />  <li>top-left</li><br />  <li>bottom</li><br />  <li>bottom-left</li><br />  <li>bottom-right</li><br />  <li>left</li><br />  <li>left-top</li><br />  <li>left-bottom</li><br />  <li>right</li><br />  <li>right-top</li><br />  <li>right-bottom</li><br /></ul></li>
</ul>
</td>
              </tr>
              <tr>
                <td>[appendToBody=false]</td>
                <td>boolean</td>
                <td><ul>
<li>Should the top and left values returned   be calculated from the body element, default is false.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides coordinates for an element to be positioned relative to<br />another element.  Passing &#39;auto&#39; as part of the placement parameter<br />will enable smart placement - where the element fits. i.e:<br />&#39;auto left-top&#39; will check to see if there is enough space to the left<br />of the hostElem to fit the targetElem, if not place right (same for secondary<br />top placement).  Available space is calculated using the viewportOffset<br />function.</p></div>
          <pre><code class="language-javascript">positionElements: function(hostElem, targetElem, placement, appendToBody) {
  hostElem = this.getRawNode(hostElem);
  targetElem = this.getRawNode(targetElem);

  // need to read from prop to support tests.
  var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
  var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

  placement = this.parsePlacement(placement);

  var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
  var targetElemPos = {top: 0, left: 0, placement: ''};

  if (placement[2]) {
    var viewportOffset = this.viewportOffset(hostElem, appendToBody);

    var targetElemStyle = $window.getComputedStyle(targetElem);
    var adjustedSize = {
      width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
      height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
    };

    placement[0] = placement[0] === 'top' &amp;&amp; adjustedSize.height &gt; viewportOffset.top &amp;&amp; adjustedSize.height &lt;= viewportOffset.bottom ? 'bottom' :
                   placement[0] === 'bottom' &amp;&amp; adjustedSize.height &gt; viewportOffset.bottom &amp;&amp; adjustedSize.height &lt;= viewportOffset.top ? 'top' :
                   placement[0] === 'left' &amp;&amp; adjustedSize.width &gt; viewportOffset.left &amp;&amp; adjustedSize.width &lt;= viewportOffset.right ? 'right' :
                   placement[0] === 'right' &amp;&amp; adjustedSize.width &gt; viewportOffset.right &amp;&amp; adjustedSize.width &lt;= viewportOffset.left ? 'left' :
                   placement[0];

    placement[1] = placement[1] === 'top' &amp;&amp; adjustedSize.height - hostElemPos.height &gt; viewportOffset.bottom &amp;&amp; adjustedSize.height - hostElemPos.height &lt;= viewportOffset.top ? 'bottom' :
                   placement[1] === 'bottom' &amp;&amp; adjustedSize.height - hostElemPos.height &gt; viewportOffset.top &amp;&amp; adjustedSize.height - hostElemPos.height &lt;= viewportOffset.bottom ? 'top' :
                   placement[1] === 'left' &amp;&amp; adjustedSize.width - hostElemPos.width &gt; viewportOffset.right &amp;&amp; adjustedSize.width - hostElemPos.width &lt;= viewportOffset.left ? 'right' :
                   placement[1] === 'right' &amp;&amp; adjustedSize.width - hostElemPos.width &gt; viewportOffset.left &amp;&amp; adjustedSize.width - hostElemPos.width &lt;= viewportOffset.right ? 'left' :
                   placement[1];

    if (placement[1] === 'center') {
      if (PLACEMENT_REGEX.vertical.test(placement[0])) {
        var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
        if (viewportOffset.left + xOverflow &lt; 0 &amp;&amp; adjustedSize.width - hostElemPos.width &lt;= viewportOffset.right) {
          placement[1] = 'left';
        } else if (viewportOffset.right + xOverflow &lt; 0 &amp;&amp; adjustedSize.width - hostElemPos.width &lt;= viewportOffset.left) {
          placement[1] = 'right';
        }
      } else {
        var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
        if (viewportOffset.top + yOverflow &lt; 0 &amp;&amp; adjustedSize.height - hostElemPos.height &lt;= viewportOffset.bottom) {
          placement[1] = 'top';
        } else if (viewportOffset.bottom + yOverflow &lt; 0 &amp;&amp; adjustedSize.height - hostElemPos.height &lt;= viewportOffset.top) {
          placement[1] = 'bottom';
        }
      }
    }
  }

  switch (placement[0]) {
    case 'top':
      targetElemPos.top = hostElemPos.top - targetHeight;
      break;
    case 'bottom':
      targetElemPos.top = hostElemPos.top + hostElemPos.height;
      break;
    case 'left':
      targetElemPos.left = hostElemPos.left - targetWidth;
      break;
    case 'right':
      targetElemPos.left = hostElemPos.left + hostElemPos.width;
      break;
  }

  switch (placement[1]) {
    case 'top':
      targetElemPos.top = hostElemPos.top;
      break;
    case 'bottom':
      targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
      break;
    case 'left':
      targetElemPos.left = hostElemPos.left;
      break;
    case 'right':
      targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
      break;
    case 'center':
      if (PLACEMENT_REGEX.vertical.test(placement[0])) {
        targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
      } else {
        targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
      }
      break;
  }

  targetElemPos.top = Math.round(targetElemPos.top);
  targetElemPos.left = Math.round(targetElemPos.left);
  targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

  return targetElemPos;
},</code></pre>
          <section id="adjustTop">
            <h1>adjustTop</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>adjustTop()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>placementClasses</td>
                <td>array</td>
                <td><ul>
<li>The array of strings of classes element should have.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>containerPosition</td>
                <td>object</td>
                <td><ul>
<li>The object with container position information</li>
</ul>
</td>
              </tr>
              <tr>
                <td>initialHeight</td>
                <td>number</td>
                <td><ul>
<li>The initial height for the elem.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>currentHeight</td>
                <td>number</td>
                <td><ul>
<li>The current height for the elem.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides a way to adjust the top positioning after first<br />render to correctly align element to top after content<br />rendering causes resized element height</p></div>
          <pre><code class="language-javascript">adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
  if (placementClasses.indexOf('top') !== -1 &amp;&amp; initialHeight !== currentHeight) {
    return {
      top: containerPosition.top - currentHeight + 'px'
    };
  }
},</code></pre>
          <section id="positionArrow">
            <h1>positionArrow</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>positionArrow()</span><span>&nbsp;</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>elem</td>
                <td>element</td>
                <td><ul>
<li>The tooltip/dropdown element.</li>
</ul>
</td>
              </tr>
              <tr>
                <td>placement</td>
                <td>string</td>
                <td><ul>
<li>The placement for the elem.</li>
</ul>
</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Provides a way for positioning tooltip &amp; dropdown<br />arrows when using placement options beyond the standard<br />left, right, top, or bottom.</p></div>
          <pre><code class="language-javascript">positionArrow: function(elem, placement) {
  elem = this.getRawNode(elem);

  var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
  if (!innerElem) {
    return;
  }

  var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

  var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
  if (!arrowElem) {
    return;
  }

  var arrowCss = {
    top: '',
    bottom: '',
    left: '',
    right: ''
  };

  placement = this.parsePlacement(placement);
  if (placement[1] === 'center') {
    // no adjustment necessary - just reset styles
    angular.element(arrowElem).css(arrowCss);
    return;
  }

  var borderProp = 'border-' + placement[0] + '-width';
  var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

  var borderRadiusProp = 'border-';
  if (PLACEMENT_REGEX.vertical.test(placement[0])) {
    borderRadiusProp += placement[0] + '-' + placement[1];
  } else {
    borderRadiusProp += placement[1] + '-' + placement[0];
  }
  borderRadiusProp += '-radius';
  var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

  switch (placement[0]) {
    case 'top':
      arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
      break;
    case 'bottom':
      arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
      break;
    case 'left':
      arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
      break;
    case 'right':
      arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
      break;
  }

  arrowCss[placement[1]] = borderRadius;

  angular.element(arrowElem).css(arrowCss);
}
    };
  }]);

angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])

.value('$datepickerPopupLiteralWarning', true)

.constant('uibDatepickerPopupConfig', {
  altInputFormats: [],
  appendToBody: false,
  clearText: 'Clear',
  closeOnDateSelection: true,
  closeText: 'Done',
  currentText: 'Today',
  datepickerPopup: 'yyyy-MM-dd',
  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
  html5Types: {
    date: 'yyyy-MM-dd',
    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
    'month': 'yyyy-MM'
  },
  onOpenFocus: true,
  showButtonBar: true,
  placement: 'auto bottom-left'
})

.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',
function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
  var cache = {},
    isHtml5DateInput = false;
  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,
    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];

  this.init = function(_ngModel_) {
    ngModel = _ngModel_;
    ngModelOptions = angular.isObject(_ngModel_.$options) ?
_ngModel_.$options :
{
  timezone: null
};
    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
$scope.$parent.$eval($attrs.closeOnDateSelection) :
datepickerPopupConfig.closeOnDateSelection;
    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
$scope.$parent.$eval($attrs.datepickerAppendToBody) :
datepickerPopupConfig.appendToBody;
    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
$scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
$attrs.datepickerPopupTemplateUrl :
datepickerPopupConfig.datepickerPopupTemplateUrl;
    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
$attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
    altInputFormats = angular.isDefined($attrs.altInputFormats) ?
$scope.$parent.$eval($attrs.altInputFormats) :
datepickerPopupConfig.altInputFormats;

    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
$scope.$parent.$eval($attrs.showButtonBar) :
datepickerPopupConfig.showButtonBar;

    if (datepickerPopupConfig.html5Types[$attrs.type]) {
dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
isHtml5DateInput = true;
    } else {
dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
$attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
  var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
  // Invalidate the $modelValue to ensure that formatters re-run
  // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
  if (newDateFormat !== dateFormat) {
    dateFormat = newDateFormat;
    ngModel.$modelValue = null;

    if (!dateFormat) {
      throw new Error('uibDatepickerPopup must have a date format specified.');
    }
  }
});
    }

    if (!dateFormat) {
throw new Error('uibDatepickerPopup must have a date format specified.');
    }

    if (isHtml5DateInput &amp;&amp; $attrs.uibDatepickerPopup) {
throw new Error('HTML5 date input types do not support custom formats.');
    }

    // popup element used to display calendar
    popupEl = angular.element('&lt;div uib-datepicker-popup-wrap&gt;&lt;div uib-datepicker&gt;&lt;/div&gt;&lt;/div&gt;');

    popupEl.attr({
'ng-model': 'date',
'ng-change': 'dateSelection(date)',
'template-url': datepickerPopupTemplateUrl
    });

    // datepicker element
    datepickerEl = angular.element(popupEl.children()[0]);
    datepickerEl.attr('template-url', datepickerTemplateUrl);

    if (!$scope.datepickerOptions) {
$scope.datepickerOptions = {};
    }

    if (isHtml5DateInput) {
if ($attrs.type === 'month') {
  $scope.datepickerOptions.datepickerMode = 'month';
  $scope.datepickerOptions.minMode = 'month';
}
    }

    datepickerEl.attr('datepicker-options', 'datepickerOptions');

    if (!isHtml5DateInput) {
// Internal API to maintain the correct ng-invalid-[key] class
ngModel.$$parserName = 'date';
ngModel.$validators.date = validator;
ngModel.$parsers.unshift(parseDate);
ngModel.$formatters.push(function(value) {
  if (ngModel.$isEmpty(value)) {
    $scope.date = value;
    return value;
  }

  if (angular.isNumber(value)) {
    value = new Date(value);
  }

  $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);

  return dateParser.filter($scope.date, dateFormat);
});
    } else {
ngModel.$formatters.push(function(value) {
  $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
  return value;
});
    }

    // Detect changes in the view from the text box
    ngModel.$viewChangeListeners.push(function() {
$scope.date = parseDateString(ngModel.$viewValue);
    });

    $element.on('keydown', inputKeydownBind);

    $popup = $compile(popupEl)($scope);
    // Prevent jQuery cache memory leak (template is now redundant after linking)
    popupEl.remove();

    if (appendToBody) {
$document.find('body').append($popup);
    } else {
$element.after($popup);
    }

    $scope.$on('$destroy', function() {
if ($scope.isOpen === true) {
  if (!$rootScope.$$phase) {
    $scope.$apply(function() {
      $scope.isOpen = false;
    });
  }
}

$popup.remove();
$element.off('keydown', inputKeydownBind);
$document.off('click', documentClickBind);
if (scrollParentEl) {
  scrollParentEl.off('scroll', positionPopup);
}
angular.element($window).off('resize', positionPopup);

//Clear all watch listeners on destroy
while (watchListeners.length) {
  watchListeners.shift()();
}
    });
  };

  $scope.getText = function(key) {
    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
  };

  $scope.isDisabled = function(date) {
    if (date === 'today') {
date = dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
    }

    var dates = {};
    angular.forEach(['minDate', 'maxDate'], function(key) {
if (!$scope.datepickerOptions[key]) {
  dates[key] = null;
} else if (angular.isDate($scope.datepickerOptions[key])) {
  dates[key] = new Date($scope.datepickerOptions[key]);
} else {
  if ($datepickerPopupLiteralWarning) {
    $log.warn('Literal date support has been deprecated, please switch to date object usage');
  }

  dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
}
    });

    return $scope.datepickerOptions &amp;&amp;
dates.minDate &amp;&amp; $scope.compare(date, dates.minDate) &lt; 0 ||
dates.maxDate &amp;&amp; $scope.compare(date, dates.maxDate) &gt; 0;
  };

  $scope.compare = function(date1, date2) {
    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
  };

  // Inner change
  $scope.dateSelection = function(dt) {
    $scope.date = dt;
    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
    $element.val(date);
    ngModel.$setViewValue(date);

    if (closeOnDateSelection) {
$scope.isOpen = false;
$element[0].focus();
    }
  };

  $scope.keydown = function(evt) {
    if (evt.which === 27) {
evt.stopPropagation();
$scope.isOpen = false;
$element[0].focus();
    }
  };

  $scope.select = function(date, evt) {
    evt.stopPropagation();

    if (date === 'today') {
var today = new Date();
if (angular.isDate($scope.date)) {
  date = new Date($scope.date);
  date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
} else {
  date = dateParser.fromTimezone(today, ngModelOptions.timezone);
  date.setHours(0, 0, 0, 0);
}
    }
    $scope.dateSelection(date);
  };

  $scope.close = function(evt) {
    evt.stopPropagation();

    $scope.isOpen = false;
    $element[0].focus();
  };

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if ($attrs.ngDisabled) {
    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
$scope.disabled = disabled;
    }));
  }

  $scope.$watch('isOpen', function(value) {
    if (value) {
if (!$scope.disabled) {
  $timeout(function() {
    positionPopup();

    if (onOpenFocus) {
      $scope.$broadcast('uib:datepicker.focus');
    }

    $document.on('click', documentClickBind);

    var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
    if (appendToBody || $position.parsePlacement(placement)[2]) {
      scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
      if (scrollParentEl) {
        scrollParentEl.on('scroll', positionPopup);
      }
    } else {
      scrollParentEl = null;
    }

    angular.element($window).on('resize', positionPopup);
  }, 0, false);
} else {
  $scope.isOpen = false;
}
    } else {
$document.off('click', documentClickBind);
if (scrollParentEl) {
  scrollParentEl.off('scroll', positionPopup);
}
angular.element($window).off('resize', positionPopup);
    }
  });

  function cameltoDash(string) {
    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
  }

  function parseDateString(viewValue) {
    var date = dateParser.parse(viewValue, dateFormat, $scope.date);
    if (isNaN(date)) {
for (var i = 0; i &lt; altInputFormats.length; i++) {
  date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
  if (!isNaN(date)) {
    return date;
  }
}
    }
    return date;
  }

  function parseDate(viewValue) {
    if (angular.isNumber(viewValue)) {
// presumably timestamp to date object
viewValue = new Date(viewValue);
    }

    if (!viewValue) {
return null;
    }

    if (angular.isDate(viewValue) &amp;&amp; !isNaN(viewValue)) {
return viewValue;
    }

    if (angular.isString(viewValue)) {
var date = parseDateString(viewValue);
if (!isNaN(date)) {
  return dateParser.fromTimezone(date, ngModelOptions.timezone);
}
    }

    return ngModel.$options &amp;&amp; ngModel.$options.allowInvalid ? viewValue : undefined;
  }

  function validator(modelValue, viewValue) {
    var value = modelValue || viewValue;

    if (!$attrs.ngRequired &amp;&amp; !value) {
return true;
    }

    if (angular.isNumber(value)) {
value = new Date(value);
    }

    if (!value) {
return true;
    }

    if (angular.isDate(value) &amp;&amp; !isNaN(value)) {
return true;
    }

    if (angular.isString(value)) {
return !isNaN(parseDateString(value));
    }

    return false;
  }

  function documentClickBind(event) {
    if (!$scope.isOpen &amp;&amp; $scope.disabled) {
return;
    }

    var popup = $popup[0];
    var dpContainsTarget = $element[0].contains(event.target);
    // The popup node may not be an element node
    // In some browsers (IE) only element nodes have the 'contains' function
    var popupContainsTarget = popup.contains !== undefined &amp;&amp; popup.contains(event.target);
    if ($scope.isOpen &amp;&amp; !(dpContainsTarget || popupContainsTarget)) {
$scope.$apply(function() {
  $scope.isOpen = false;
});
    }
  }

  function inputKeydownBind(evt) {
    if (evt.which === 27 &amp;&amp; $scope.isOpen) {
evt.preventDefault();
evt.stopPropagation();
$scope.$apply(function() {
  $scope.isOpen = false;
});
$element[0].focus();
    } else if (evt.which === 40 &amp;&amp; !$scope.isOpen) {
evt.preventDefault();
evt.stopPropagation();
$scope.$apply(function() {
  $scope.isOpen = true;
});
    }
  }

  function positionPopup() {
    if ($scope.isOpen) {
var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
var position = $position.positionElements($element, dpElement, placement, appendToBody);
dpElement.css({top: position.top + 'px', left: position.left + 'px'});
if (dpElement.hasClass('uib-position-measure')) {
  dpElement.removeClass('uib-position-measure');
}
    }
  }

  $scope.$on('uib:datepicker.mode', function() {
    $timeout(positionPopup, 0, false);
  });
}])

.directive('uibDatepickerPopup', function() {
  return {
    require: ['ngModel', 'uibDatepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
datepickerOptions: '=?',
isOpen: '=?',
currentText: '@',
clearText: '@',
closeText: '@'
    },
    link: function(scope, element, attrs, ctrls) {
var ngModel = ctrls[0],
  ctrl = ctrls[1];

ctrl.init(ngModel);
    }
  };
})

.directive('uibDatepickerPopupWrap', function() {
  return {
    restrict: 'A',
    transclude: true,
    templateUrl: function(element, attrs) {
return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
    }
  };
});

angular.module('ui.bootstrap.debounce', [])</code></pre>
          <div class="description"><p>A helper, internal service that debounces a function</p></div>
          <pre><code class="language-javascript">.factory('$$debounce', ['$timeout', function($timeout) {
  return function(callback, debounceTime) {
    var timeoutPromise;

    return function() {
      var self = this;
      var args = Array.prototype.slice.call(arguments);
      if (timeoutPromise) {
        $timeout.cancel(timeoutPromise);
      }

      timeoutPromise = $timeout(function() {
        callback.apply(self, args);
      }, debounceTime);
    };
  };
}]);

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])

.constant('uibDropdownConfig', {
appendToOpenClass: 'uib-dropdown-open',
openClass: 'open'
})

.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
var openScope = null;

this.open = function(dropdownScope, element) {
  if (!openScope) {
    $document.on('click', closeDropdown);
  }

  if (openScope &amp;&amp; openScope !== dropdownScope) {
    openScope.isOpen = false;
  }

  openScope = dropdownScope;
};

this.close = function(dropdownScope, element) {
  if (openScope === dropdownScope) {
    openScope = null;
    $document.off('click', closeDropdown);
    $document.off('keydown', this.keybindFilter);
  }
};

var closeDropdown = function(evt) {
  // This method may still be called during the same mouse event that
  // unbound this event handler. So check openScope before proceeding.
  if (!openScope) { return; }

  if (evt &amp;&amp; openScope.getAutoClose() === 'disabled') { return; }

  if (evt &amp;&amp; evt.which === 3) { return; }

  var toggleElement = openScope.getToggleElement();
  if (evt &amp;&amp; toggleElement &amp;&amp; toggleElement[0].contains(evt.target)) {
    return;
  }

  var dropdownElement = openScope.getDropdownElement();
  if (evt &amp;&amp; openScope.getAutoClose() === 'outsideClick' &amp;&amp;
    dropdownElement &amp;&amp; dropdownElement[0].contains(evt.target)) {
    return;
  }

  openScope.isOpen = false;
  openScope.focusToggleElement();

  if (!$rootScope.$$phase) {
    openScope.$apply();
  }
};

this.keybindFilter = function(evt) {
  var dropdownElement = openScope.getDropdownElement();
  var toggleElement = openScope.getToggleElement();
  var dropdownElementTargeted = dropdownElement &amp;&amp; dropdownElement[0].contains(evt.target);
  var toggleElementTargeted = toggleElement &amp;&amp; toggleElement[0].contains(evt.target);
  if (evt.which === 27) {
    evt.stopPropagation();
    openScope.focusToggleElement();
    closeDropdown();
  } else if (openScope.isKeynavEnabled() &amp;&amp; [38, 40].indexOf(evt.which) !== -1 &amp;&amp; openScope.isOpen &amp;&amp; (dropdownElementTargeted || toggleElementTargeted)) {
    evt.preventDefault();
    evt.stopPropagation();
    openScope.focusDropdownEntry(evt.which);
  }
};
}])

.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
var self = this,
  scope = $scope.$new(), // create a child scope so we are not polluting original one
  templateScope,
  appendToOpenClass = dropdownConfig.appendToOpenClass,
  openClass = dropdownConfig.openClass,
  getIsOpen,
  setIsOpen = angular.noop,
  toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
  appendToBody = false,
  appendTo = null,
  keynavEnabled = false,
  selectedOption = null,
  body = $document.find('body');

$element.addClass('dropdown');

this.init = function() {
  if ($attrs.isOpen) {
    getIsOpen = $parse($attrs.isOpen);
    setIsOpen = getIsOpen.assign;

    $scope.$watch(getIsOpen, function(value) {
      scope.isOpen = !!value;
    });
  }

  if (angular.isDefined($attrs.dropdownAppendTo)) {
    var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
    if (appendToEl) {
      appendTo = angular.element(appendToEl);
    }
  }

  appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
  keynavEnabled = angular.isDefined($attrs.keyboardNav);

  if (appendToBody &amp;&amp; !appendTo) {
    appendTo = body;
  }

  if (appendTo &amp;&amp; self.dropdownMenu) {
    appendTo.append(self.dropdownMenu);
    $element.on('$destroy', function handleDestroyEvent() {
      self.dropdownMenu.remove();
    });
  }
};

this.toggle = function(open) {
  scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  if (angular.isFunction(setIsOpen)) {
    setIsOpen(scope, scope.isOpen);
  }

  return scope.isOpen;
};

// Allow other directives to watch status
this.isOpen = function() {
  return scope.isOpen;
};

scope.getToggleElement = function() {
  return self.toggleElement;
};

scope.getAutoClose = function() {
  return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
};

scope.getElement = function() {
  return $element;
};

scope.isKeynavEnabled = function() {
  return keynavEnabled;
};

scope.focusDropdownEntry = function(keyCode) {
  var elems = self.dropdownMenu ? //If append to body is used.
    angular.element(self.dropdownMenu).find('a') :
    $element.find('ul').eq(0).find('a');

  switch (keyCode) {
    case 40: {
      if (!angular.isNumber(self.selectedOption)) {
        self.selectedOption = 0;
      } else {
        self.selectedOption = self.selectedOption === elems.length - 1 ?
          self.selectedOption :
          self.selectedOption + 1;
      }
      break;
    }
    case 38: {
      if (!angular.isNumber(self.selectedOption)) {
        self.selectedOption = elems.length - 1;
      } else {
        self.selectedOption = self.selectedOption === 0 ?
          0 : self.selectedOption - 1;
      }
      break;
    }
  }
  elems[self.selectedOption].focus();
};

scope.getDropdownElement = function() {
  return self.dropdownMenu;
};

scope.focusToggleElement = function() {
  if (self.toggleElement) {
    self.toggleElement[0].focus();
  }
};

scope.$watch('isOpen', function(isOpen, wasOpen) {
  if (appendTo &amp;&amp; self.dropdownMenu) {
    var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
      css,
      rightalign,
      scrollbarPadding,
      scrollbarWidth = 0;

    css = {
      top: pos.top + 'px',
      display: isOpen ? 'block' : 'none'
    };

    rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
    if (!rightalign) {
      css.left = pos.left + 'px';
      css.right = 'auto';
    } else {
      css.left = 'auto';
      scrollbarPadding = $position.scrollbarPadding(appendTo);

      if (scrollbarPadding.heightOverflow &amp;&amp; scrollbarPadding.scrollbarWidth) {
        scrollbarWidth = scrollbarPadding.scrollbarWidth;
      }

      css.right = window.innerWidth - scrollbarWidth -
        (pos.left + $element.prop('offsetWidth')) + 'px';
    }

    // Need to adjust our positioning to be relative to the appendTo container
    // if it's not the body element
    if (!appendToBody) {
      var appendOffset = $position.offset(appendTo);

      css.top = pos.top - appendOffset.top + 'px';

      if (!rightalign) {
        css.left = pos.left - appendOffset.left + 'px';
      } else {
        css.right = window.innerWidth -
          (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
      }
    }

    self.dropdownMenu.css(css);
  }

  var openContainer = appendTo ? appendTo : $element;
  var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);

  if (hasOpenClass === !isOpen) {
    $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
      if (angular.isDefined(isOpen) &amp;&amp; isOpen !== wasOpen) {
        toggleInvoker($scope, { open: !!isOpen });
      }
    });
  }

  if (isOpen) {
    if (self.dropdownMenuTemplateUrl) {
      $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
        templateScope = scope.$new();
        $compile(tplContent.trim())(templateScope, function(dropdownElement) {
          var newEl = dropdownElement;
          self.dropdownMenu.replaceWith(newEl);
          self.dropdownMenu = newEl;
          $document.on('keydown', uibDropdownService.keybindFilter);
        });
      });
    } else {
      $document.on('keydown', uibDropdownService.keybindFilter);
    }

    scope.focusToggleElement();
    uibDropdownService.open(scope, $element);
  } else {
    uibDropdownService.close(scope, $element);
    if (self.dropdownMenuTemplateUrl) {
      if (templateScope) {
        templateScope.$destroy();
      }
      var newEl = angular.element('&lt;ul class=&quot;dropdown-menu&quot;&gt;&lt;/ul&gt;');
      self.dropdownMenu.replaceWith(newEl);
      self.dropdownMenu = newEl;
    }

    self.selectedOption = null;
  }

  if (angular.isFunction(setIsOpen)) {
    setIsOpen($scope, isOpen);
  }
});
}])

.directive('uibDropdown', function() {
return {
  controller: 'UibDropdownController',
  link: function(scope, element, attrs, dropdownCtrl) {
    dropdownCtrl.init();
  }
};
})

.directive('uibDropdownMenu', function() {
return {
  restrict: 'A',
  require: '?^uibDropdown',
  link: function(scope, element, attrs, dropdownCtrl) {
    if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
      return;
    }

    element.addClass('dropdown-menu');

    var tplUrl = attrs.templateUrl;
    if (tplUrl) {
      dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
    }

    if (!dropdownCtrl.dropdownMenu) {
      dropdownCtrl.dropdownMenu = element;
    }
  }
};
})

.directive('uibDropdownToggle', function() {
return {
  require: '?^uibDropdown',
  link: function(scope, element, attrs, dropdownCtrl) {
    if (!dropdownCtrl) {
      return;
    }

    element.addClass('dropdown-toggle');

    dropdownCtrl.toggleElement = element;

    var toggleDropdown = function(event) {
      event.preventDefault();

      if (!element.hasClass('disabled') &amp;&amp; !attrs.disabled) {
        scope.$apply(function() {
          dropdownCtrl.toggle();
        });
      }
    };

    element.bind('click', toggleDropdown);

    // WAI-ARIA
    element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
    scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
      element.attr('aria-expanded', !!isOpen);
    });

    scope.$on('$destroy', function() {
      element.unbind('click', toggleDropdown);
    });
  }
};
});

angular.module('ui.bootstrap.stackedMap', [])</code></pre>
          <div class="description"><p>A helper, internal data structure that acts as a map but also allows getting / removing<br />elements in the LIFO order</p></div>
          <pre><code class="language-javascript">.factory('$$stackedMap', function() {
  return {
    createNew: function() {
      var stack = [];

      return {
        add: function(key, value) {
          stack.push({
            key: key,
            value: value
          });
        },
        get: function(key) {
          for (var i = 0; i &lt; stack.length; i++) {
            if (key === stack[i].key) {
              return stack[i];
            }
          }
        },
        keys: function() {
          var keys = [];
          for (var i = 0; i &lt; stack.length; i++) {
            keys.push(stack[i].key);
          }
          return keys;
        },
        top: function() {
          return stack[stack.length - 1];
        },
        remove: function(key) {
          var idx = -1;
          for (var i = 0; i &lt; stack.length; i++) {
            if (key === stack[i].key) {
              idx = i;
              break;
            }
          }
          return stack.splice(idx, 1)[0];
        },
        removeTop: function() {
          return stack.pop();
        },
        length: function() {
          return stack.length;
        }
      };
    }
  };
});
angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position'])</code></pre>
          <div class="description"><p>A helper, internal data structure that stores all references attached to key</p></div>
          <pre><code class="language-javascript">.factory('$$multiMap', function() {
  return {
    createNew: function() {
      var map = {};

      return {
        entries: function() {
          return Object.keys(map).map(function(key) {
            return {
              key: key,
              value: map[key]
            };
          });
        },
        get: function(key) {
          return map[key];
        },
        hasKey: function(key) {
          return !!map[key];
        },
        keys: function() {
          return Object.keys(map);
        },
        put: function(key, value) {
          if (!map[key]) {
            map[key] = [];
          }

          map[key].push(value);
        },
        remove: function(key, value) {
          var values = map[key];

          if (!values) {
            return;
          }

          var idx = values.indexOf(value);

          if (idx !== -1) {
            values.splice(idx, 1);
          }

          if (!values.length) {
            delete map[key];
          }
        }
      };
    }
  };
})</code></pre>
          <div class="description"><p>Pluggable resolve mechanism for the modal resolve resolution<br />Supports UI Router&#39;s $resolve service</p></div>
          <pre><code class="language-javascript">.provider('$uibResolve', function() {
  var resolve = this;
  this.resolver = null;

  this.setResolver = function(resolver) {
    this.resolver = resolver;
  };

  this.$get = ['$injector', '$q', function($injector, $q) {
    var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
    return {
      resolve: function(invocables, locals, parent, self) {
        if (resolver) {
          return resolver.resolve(invocables, locals, parent, self);
        }

        var promises = [];

        angular.forEach(invocables, function(value) {
          if (angular.isFunction(value) || angular.isArray(value)) {
            promises.push($q.resolve($injector.invoke(value)));
          } else if (angular.isString(value)) {
            promises.push($q.resolve($injector.get(value)));
          } else {
            promises.push($q.resolve(value));
          }
        });

        return $q.all(promises).then(function(resolves) {
          var resolveObj = {};
          var resolveIter = 0;
          angular.forEach(invocables, function(value, key) {
            resolveObj[key] = resolves[resolveIter++];
          });

          return resolveObj;
        });
      }
    };
  }];
})</code></pre>
          <div class="description"><p>A helper directive for the $modal service. It creates a backdrop element.</p></div>
          <pre><code class="language-javascript">.directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
function($animate, $injector, $modalStack) {
  return {
    restrict: 'A',
    compile: function(tElement, tAttrs) {
      tElement.addClass(tAttrs.backdropClass);
      return linkFn;
    }
  };

  function linkFn(scope, element, attrs) {
    if (attrs.modalInClass) {
      $animate.addClass(element, attrs.modalInClass);

      scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
        var done = setIsAsync();
        if (scope.modalOptions.animation) {
          $animate.removeClass(element, attrs.modalInClass).then(done);
        } else {
          done();
        }
      });
    }
  }
}])

.directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
function($modalStack, $q, $animateCss, $document) {
  return {
    scope: {
      index: '@'
    },
    restrict: 'A',
    transclude: true,
    templateUrl: function(tElement, tAttrs) {
      return tAttrs.templateUrl || 'uib/template/modal/window.html';
    },
    link: function(scope, element, attrs) {
      element.addClass(attrs.windowTopClass || '');
      scope.size = attrs.size;

      scope.close = function(evt) {
        var modal = $modalStack.getTop();
        if (modal &amp;&amp; modal.value.backdrop &amp;&amp;
          modal.value.backdrop !== 'static' &amp;&amp;
          evt.target === evt.currentTarget) {
          evt.preventDefault();
          evt.stopPropagation();
          $modalStack.dismiss(modal.key, 'backdrop click');
        }
      };

      // moved from template to fix issue #2280
      element.on('click', scope.close);

      // This property is only added to the scope for the purpose of detecting when this directive is rendered.
      // We can detect that by using this property in the template associated with this directive and then use
      // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
      scope.$isRendered = true;

      // Deferred object that will be resolved when this modal is render.
      var modalRenderDeferObj = $q.defer();
      // Resolve render promise post-digest
      scope.$$postDigest(function() {
        modalRenderDeferObj.resolve();
      });

      modalRenderDeferObj.promise.then(function() {
        var animationPromise = null;

        if (attrs.modalInClass) {
          animationPromise = $animateCss(element, {
            addClass: attrs.modalInClass
          }).start();

          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            $animateCss(element, {
              removeClass: attrs.modalInClass
            }).start().then(done);
          });
        }


        $q.when(animationPromise).then(function() {
          // Notify {@link $modalStack} that modal is rendered.
          var modal = $modalStack.getTop();
          if (modal) {
            $modalStack.modalRendered(modal.key);
          }</code></pre>
          <section id="if">
            <h1>if</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>if()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>If something within the freshly-opened modal already has focus (perhaps via a<br />directive that causes focus). then no need to try and focus anything.</p></div>
          <pre><code class="language-javascript">if (!($document[0].activeElement &amp;&amp; element[0].contains($document[0].activeElement))) {
  var inputWithAutofocus = element[0].querySelector('[autofocus]');</code></pre>
          <section id="if">
            <h1>if</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>if()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Auto-focusing of a freshly-opened modal element causes any child elements<br />with the autofocus attribute to lose focus. This is an issue on touch<br />based devices which will show and then hide the onscreen keyboard.<br />Attempts to refocus the autofocus element via JavaScript will not reopen<br />the onscreen keyboard. Fixed by updated the focusing logic to only autofocus<br />the modal element if the modal does not contain an autofocus element.</p></div>
          <pre><code class="language-javascript">if (inputWithAutofocus) {
  inputWithAutofocus.focus();
} else {
  element[0].focus();
}
            }
          });
        });
      }
    };
  }])

  .directive('uibModalAnimationClass', function() {
    return {
      compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }
    };
  })

  .directive('uibModalTransclude', ['$animate', function($animate) {
    return {
      link: function(scope, element, attrs, controller, transclude) {
        transclude(scope.$parent, function(clone) {
          element.empty();
          $animate.enter(clone, element);
        });
      }
    };
  }])

  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',
    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };
      var topModalIndex = 0;
      var previousTopOpenedModal = null;

      //Modal focus behavior
      var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' +
        'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' +
        'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
      var scrollbarPadding;
      var SNAKE_CASE_REGEXP = /[A-Z]/g;

      // TODO: extract into common dependency with tooltip
      function snake_case(name) {
        var separator = '-';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }

      function isVisible(element) {
        return !!(element.offsetWidth ||
          element.offsetHeight ||
          element.getClientRects().length);
      }

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i &lt; opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }

        // If any backdrop exist, ensure that it's index is always
        // right below the top modal
        if (topBackdropIndex &gt; -1 &amp;&amp; topBackdropIndex &lt; topModalIndex) {
          topBackdropIndex = topModalIndex;
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;

        //clean up the stack
        openedWindows.remove(modalInstance);
        previousTopOpenedModal = openedWindows.top();
        if (previousTopOpenedModal) {
          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
        }

        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          var areAnyOpen = openedClasses.hasKey(modalBodyClass);
          appendToElement.toggleClass(modalBodyClass, areAnyOpen);
          if (!areAnyOpen &amp;&amp; scrollbarPadding &amp;&amp; scrollbarPadding.heightOverflow &amp;&amp; scrollbarPadding.scrollbarWidth) {
            if (scrollbarPadding.originalRight) {
appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});
            } else {
appendToElement.css({paddingRight: ''});
            }
            scrollbarPadding = null;
          }
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();

        //move focus to specified element if available, or else to body
        if (elementToReceiveFocus &amp;&amp; elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }

      // Add or remove &quot;windowTopClass&quot; from the top window in the stack
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;

        if (openedWindows.length() &gt; 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        //remove backdrop if no longer needed
        if (backdropDomEl &amp;&amp; backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }

          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

        // Note that it's intentional that asyncPromise might be null.
        // That's when setIsAsync has not been called during the
        // NOW_CLOSING_EVENT broadcast.
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          $animate.leave(domEl).then(function() {
            if (done) {
done();
            }

            domEl.remove();
            if (closedDeferred) {
closedDeferred.resolve();
            }
          });

          scope.$destroy();
        }
      }

      $document.on('keydown', keydownListener);

      $rootScope.$on('$destroy', function() {
        $document.off('keydown', keydownListener);
      });

      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }

        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27: {
if (modal.value.keyboard) {
  evt.preventDefault();
  $rootScope.$apply(function() {
    $modalStack.dismiss(modal.key, 'escape key press');
  });
}
break;
            }
            case 9: {
var list = $modalStack.loadFocusElementList(modal);
var focusChanged = false;
if (evt.shiftKey) {
  if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
    focusChanged = $modalStack.focusLastFocusableElement(list);
  }
} else {
  if ($modalStack.isFocusInLastItem(evt, list)) {
    focusChanged = $modalStack.focusFirstFocusableElement(list);
  }
}

if (focusChanged) {
  evt.preventDefault();
  evt.stopPropagation();
}

break;
            }
          }
        }
      }

      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

        toggleTopWindowClass(false);

        // Store the current top first, to determine what index we ought to use
        // for the current top modal
        previousTopOpenedModal = openedWindows.top();

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });

        openedClasses.put(modalBodyClass, modalInstance);

        var appendToElement = modal.appendTo,
            currBackdropIndex = backdropIndex();

        if (!appendToElement.length) {
          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
        }

        if (currBackdropIndex &gt;= 0 &amp;&amp; !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('&lt;div uib-modal-backdrop=&quot;modal-backdrop&quot;&gt;&lt;/div&gt;');
          backdropDomEl.attr({
            'class': 'modal-backdrop',
            'ng-style': '{\'z-index\': 1040 + (index &amp;&amp; 1 || 0) + index*10}',
            'uib-modal-animation-class': 'fade',
            'modal-in-class': 'in'
          });
          if (modal.backdropClass) {
            backdropDomEl.addClass(modal.backdropClass);
          }

          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
          if ($uibPosition.isScrollable(appendToElement)) {
            scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
            if (scrollbarPadding.heightOverflow &amp;&amp; scrollbarPadding.scrollbarWidth) {
appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});
            }
          }
        }

        var content;
        if (modal.component) {
          content = document.createElement(snake_case(modal.component.name));
          content = angular.element(content);
          content.attr({
            resolve: '$resolve',
            'modal-instance': '$uibModalInstance',
            close: 'close($value)',
            dismiss: 'dismiss($value)'
          });
          content = $compile(content)(modal.scope);
        } else {
          content = modal.content;
        }

        // Set the top modal index based on the index of the previous top modal
        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
        var angularDomEl = angular.element('&lt;div uib-modal-window=&quot;modal-window&quot;&gt;&lt;/div&gt;');
        angularDomEl.attr({
          'class': 'modal',
          'template-url': modal.windowTemplateUrl,
          'window-top-class': modal.windowTopClass,
          'role': 'dialog',
          'aria-labelledby': modal.ariaLabelledBy,
          'aria-describedby': modal.ariaDescribedBy,
          'size': modal.size,
          'index': topModalIndex,
          'animate': 'animate',
          'ng-style': '{\'z-index\': 1050 + $$topModalIndex*10, display: \'block\'}',
          'tabindex': -1,
          'uib-modal-animation-class': 'fade',
          'modal-in-class': 'in'
        }).append(content);
        if (modal.windowClass) {
          angularDomEl.addClass(modal.windowClass);
        }

        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }

        appendToElement.addClass(modalBodyClass);
        if (modal.scope) {
          // we need to explicitly add the modal index to the modal scope
          // because it is needed by ngStyle to compute the zIndex property.
          modal.scope.$$topModalIndex = topModalIndex;
        }
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);

        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }

      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow &amp;&amp; broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow &amp;&amp; broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal &amp;&amp; this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function() {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      $modalStack.focusFirstFocusableElement = function(list) {
        if (list.length &gt; 0) {
          list[0].focus();
          return true;
        }
        return false;
      };

      $modalStack.focusLastFocusableElement = function(list) {
        if (list.length &gt; 0) {
          list[list.length - 1].focus();
          return true;
        }
        return false;
      };

      $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt &amp;&amp; modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl &amp;&amp; modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };

      $modalStack.isFocusInFirstItem = function(evt, list) {
        if (list.length &gt; 0) {
          return (evt.target || evt.srcElement) === list[0];
        }
        return false;
      };

      $modalStack.isFocusInLastItem = function(evt, list) {
        if (list.length &gt; 0) {
          return (evt.target || evt.srcElement) === list[list.length - 1];
        }
        return false;
      };

      $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
          var modalDomE1 = modalWindow.value.modalDomEl;
          if (modalDomE1 &amp;&amp; modalDomE1.length) {
            var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
            return elements ?
Array.prototype.filter.call(elements, function(element) {
  return isVisible(element);
}) : elements;
          }
        }
      };

      return $modalStack;
    }])

  .provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, //can also be false or 'static'
        keyboard: true
      },
      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
$templateRequest(angular.isFunction(options.templateUrl) ?
  options.templateUrl() : options.templateUrl);
          }

          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };

          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
result: modalResultDeferred.promise,
opened: modalOpenedDeferred.promise,
closed: modalClosedDeferred.promise,
rendered: modalRenderDeferred.promise,
close: function (result) {
  return $modalStack.close(modalInstance, result);
},
dismiss: function (reason) {
  return $modalStack.dismiss(modalInstance, reason);
}
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

            //verify options
            if (!modalOptions.component &amp;&amp; !modalOptions.template &amp;&amp; !modalOptions.templateUrl) {
throw new Error('One of component or template or templateUrl options is required.');
            }

            var templateAndResolvePromise;
            if (modalOptions.component) {
templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));
            } else {
templateAndResolvePromise =
  $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
            }

            function resolveWithTemplate() {
return templateAndResolvePromise;
            }

            // Wait for the resolution of the existing promise chain.
            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
            // Then add to $modalStack and resolve opened.
            // Finally clean up the chain variable if no subsequent modal has overwritten it.
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
.then(resolveWithTemplate, resolveWithTemplate)
.then(function resolveSuccess(tplAndVars) {
  var providedScope = modalOptions.scope || $rootScope;

  var modalScope = providedScope.$new();
  modalScope.$close = modalInstance.close;
  modalScope.$dismiss = modalInstance.dismiss;

  modalScope.$on('$destroy', function() {
    if (!modalScope.$$uibDestructionScheduled) {
      modalScope.$dismiss('$uibUnscheduledDestruction');
    }
  });

  var modal = {
    scope: modalScope,
    deferred: modalResultDeferred,
    renderDeferred: modalRenderDeferred,
    closedDeferred: modalClosedDeferred,
    animation: modalOptions.animation,
    backdrop: modalOptions.backdrop,
    keyboard: modalOptions.keyboard,
    backdropClass: modalOptions.backdropClass,
    windowTopClass: modalOptions.windowTopClass,
    windowClass: modalOptions.windowClass,
    windowTemplateUrl: modalOptions.windowTemplateUrl,
    ariaLabelledBy: modalOptions.ariaLabelledBy,
    ariaDescribedBy: modalOptions.ariaDescribedBy,
    size: modalOptions.size,
    openedClass: modalOptions.openedClass,
    appendTo: modalOptions.appendTo
  };

  var component = {};
  var ctrlInstance, ctrlInstantiate, ctrlLocals = {};

  if (modalOptions.component) {
    constructLocals(component, false, true, false);
    component.name = modalOptions.component;
    modal.component = component;
  } else if (modalOptions.controller) {
    constructLocals(ctrlLocals, true, false, true);

    // the third param will make the controller instantiate later,private api
    // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126
    ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
    if (modalOptions.controllerAs &amp;&amp; modalOptions.bindToController) {
      ctrlInstance = ctrlInstantiate.instance;
      ctrlInstance.$close = modalScope.$close;
      ctrlInstance.$dismiss = modalScope.$dismiss;
      angular.extend(ctrlInstance, {
        $resolve: ctrlLocals.$scope.$resolve
      }, providedScope);
    }

    ctrlInstance = ctrlInstantiate();

    if (angular.isFunction(ctrlInstance.$onInit)) {
      ctrlInstance.$onInit();
    }
  }

  if (!modalOptions.component) {
    modal.content = tplAndVars[0];
  }

  $modalStack.open(modalInstance, modal);
  modalOpenedDeferred.resolve(true);

  function constructLocals(obj, template, instanceOnScope, injectable) {
    obj.$scope = modalScope;
    obj.$scope.$resolve = {};
    if (instanceOnScope) {
      obj.$scope.$uibModalInstance = modalInstance;
    } else {
      obj.$uibModalInstance = modalInstance;
    }

    var resolves = template ? tplAndVars[1] : tplAndVars;
    angular.forEach(resolves, function(value, key) {
      if (injectable) {
        obj[key] = value;
      }

      obj.$scope.$resolve[key] = value;
    });
  }
            }, function resolveError(reason) {
modalOpenedDeferred.reject(reason);
modalResultDeferred.reject(reason);
            })['finally'](function() {
if (promiseChain === samePromise) {
  promiseChain = null;
}
            });

            return modalInstance;
          };

          return $modal;
        }
      ]
    };

    return $modalProvider;
  });

angular.module('ui.bootstrap.paging', [])</code></pre>
          <div class="description"><p>Helper internal service for generating common controller code between the<br />pager and pagination components</p></div>
          <pre><code class="language-javascript">.factory('uibPaging', ['$parse', function($parse) {
  return {
    create: function(ctrl, $scope, $attrs) {
      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl
      ctrl._watchers = [];

      ctrl.init = function(ngModelCtrl, config) {
        ctrl.ngModelCtrl = ngModelCtrl;
        ctrl.config = config;

        ngModelCtrl.$render = function() {
          ctrl.render();
        };

        if ($attrs.itemsPerPage) {
          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
            ctrl.itemsPerPage = parseInt(value, 10);
            $scope.totalPages = ctrl.calculateTotalPages();
            ctrl.updatePage();
          }));
        } else {
          ctrl.itemsPerPage = config.itemsPerPage;
        }

        $scope.$watch('totalItems', function(newTotal, oldTotal) {
          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
            $scope.totalPages = ctrl.calculateTotalPages();
            ctrl.updatePage();
          }
        });
      };

      ctrl.calculateTotalPages = function() {
        var totalPages = ctrl.itemsPerPage &lt; 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
        return Math.max(totalPages || 0, 1);
      };

      ctrl.render = function() {
        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
      };

      $scope.selectPage = function(page, evt) {
        if (evt) {
          evt.preventDefault();
        }

        var clickAllowed = !$scope.ngDisabled || !evt;
        if (clickAllowed &amp;&amp; $scope.page !== page &amp;&amp; page &gt; 0 &amp;&amp; page &lt;= $scope.totalPages) {
          if (evt &amp;&amp; evt.target) {
            evt.target.blur();
          }
          ctrl.ngModelCtrl.$setViewValue(page);
          ctrl.ngModelCtrl.$render();
        }
      };

      $scope.getText = function(key) {
        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
      };

      $scope.noPrevious = function() {
        return $scope.page === 1;
      };

      $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
      };

      ctrl.updatePage = function() {
        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

        if ($scope.page &gt; $scope.totalPages) {
          $scope.selectPage($scope.totalPages);
        } else {
          ctrl.ngModelCtrl.$render();
        }
      };

      $scope.$on('$destroy', function() {
        while (ctrl._watchers.length) {
          ctrl._watchers.shift()();
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])

.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

  uibPaging.create(this, $scope, $attrs);
}])

.constant('uibPagerConfig', {
  itemsPerPage: 10,
  previousText: ' Previous',
  nextText: 'Next ',
  align: true
})

.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
  return {
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@',
      ngDisabled: '='
    },
    require: ['uibPager', '?ngModel'],
    restrict: 'A',
    controller: 'UibPagerController',
    controllerAs: 'pager',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/pager/pager.html';
    },
    link: function(scope, element, attrs, ctrls) {
      element.addClass('pager');
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
        return; // do nothing if no ng-model
      }

      paginationCtrl.init(ngModelCtrl, uibPagerConfig);
    }
  };
}]);

angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
  var ctrl = this;
  // Setup configuration parameters
  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;
  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;

  uibPaging.create(this, $scope, $attrs);

  if ($attrs.maxSize) {
    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
      maxSize = parseInt(value, 10);
      ctrl.render();
    }));
  }

  // Create page object used in template
  function makePage(number, text, isActive) {
    return {
      number: number,
      text: text,
      active: isActive
    };
  }

  function getPages(currentPage, totalPages) {
    var pages = [];

    // Default page limits
    var startPage = 1, endPage = totalPages;
    var isMaxSized = angular.isDefined(maxSize) &amp;&amp; maxSize &lt; totalPages;

    // recompute if maxSize
    if (isMaxSized) {
      if (rotate) {
        // Current page is displayed in the middle of the visible ones
        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
        endPage = startPage + maxSize - 1;

        // Adjust if limit is exceeded
        if (endPage &gt; totalPages) {
          endPage = totalPages;
          startPage = endPage - maxSize + 1;
        }
      } else {
        // Visible pages are paginated with maxSize
        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

        // Adjust last page if limit is exceeded
        endPage = Math.min(startPage + maxSize - 1, totalPages);
      }
    }

    // Add page number links
    for (var number = startPage; number &lt;= endPage; number++) {
      var page = makePage(number, pageLabel(number), number === currentPage);
      pages.push(page);
    }

    // Add links to move between page sets
    if (isMaxSized &amp;&amp; maxSize &gt; 0 &amp;&amp; (!rotate || forceEllipses || boundaryLinkNumbers)) {
      if (startPage &gt; 1) {
        if (!boundaryLinkNumbers || startPage &gt; 3) { //need ellipsis for all options unless range is too close to beginning
        var previousPageSet = makePage(startPage - 1, '...', false);
        pages.unshift(previousPageSet);
      }
        if (boundaryLinkNumbers) {
          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential
            var secondPageLink = makePage(2, '2', false);
            pages.unshift(secondPageLink);
          }
          //add the first page
          var firstPageLink = makePage(1, '1', false);
          pages.unshift(firstPageLink);
        }
      }

      if (endPage &lt; totalPages) {
        if (!boundaryLinkNumbers || endPage &lt; totalPages - 2) { //need ellipsis for all options unless range is too close to end
        var nextPageSet = makePage(endPage + 1, '...', false);
        pages.push(nextPageSet);
      }
        if (boundaryLinkNumbers) {
          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential
            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
            pages.push(secondToLastPageLink);
          }
          //add the last page
          var lastPageLink = makePage(totalPages, totalPages, false);
          pages.push(lastPageLink);
        }
      }
    }
    return pages;
  }

  var originalRender = this.render;
  this.render = function() {
    originalRender();
    if ($scope.page &gt; 0 &amp;&amp; $scope.page &lt;= $scope.totalPages) {
      $scope.pages = getPages($scope.page, $scope.totalPages);
    }
  };
}])

.constant('uibPaginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  boundaryLinkNumbers: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true,
  forceEllipses: false
})

.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
  return {
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      ngDisabled:'='
    },
    require: ['uibPagination', '?ngModel'],
    restrict: 'A',
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/pagination/pagination.html';
    },
    link: function(scope, element, attrs, ctrls) {
      element.addClass('pagination');
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
    }
  };
}]);</code></pre>
          <div class="description"><p>The following features are still outstanding: animation as a<br />function, placement as a function, inside, support for more triggers than<br />just mouse enter/leave, html tooltips, and selector delegation.</p></div>
          <pre><code class="language-javascript">angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])</code></pre>
          <div class="description"><p>The $tooltip service creates tooltip- and popover-like directives as well as<br />houses global options for them.</p></div>
          <pre><code class="language-javascript">.provider('$uibTooltip', function() {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    placementClassPrefix: '',
    animation: true,
    popupDelay: 0,
    popupCloseDelay: 0,
    useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'outsideClick': 'outsideClick',
    'focus': 'blur',
    'none': ''
  };

  // The options specified to the provider globally.
  var globalOptions = {};</code></pre>
          <section id="options">
            <h1>options</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>this.options()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p><code>options({})</code> allows global configuration of all tooltips in the<br />application.</p><p>  var app = angular.module( &#39;App&#39;, [&#39;ui.bootstrap.tooltip&#39;], function( $tooltipProvider ) {<br />    // place tooltips left instead of top by default<br />    $tooltipProvider.options( { placement: &#39;left&#39; } );<br />  });</p></div>
          <pre><code class="language-javascript">this.options = function(value) {
	angular.extend(globalOptions, value);
};</code></pre>
          <section id="setTriggers">
            <h1>setTriggers</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>this.setTriggers()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>This allows you to extend the set of trigger mappings available. E.g.:</p><p>  $tooltipProvider.setTriggers( { &#39;openTrigger&#39;: &#39;closeTrigger&#39; } );</p></div>
          <pre><code class="language-javascript">this.setTriggers = function setTriggers(triggers) {
  angular.extend(triggerMap, triggers);
};</code></pre>
          <section id="snake_case">
            <h1>snake_case</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>snake_case()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>This is a helper function for translating camel-case to snake_case.</p></div>
          <pre><code class="language-javascript">function snake_case(name) {
  var regexp = /[A-Z]/g;
  var separator = '-';
  return name.replace(regexp, function(letter, pos) {
    return (pos ? separator : '') + letter.toLowerCase();
  });
}</code></pre>
          <section id="$get">
            <h1>$get</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-success radius ctx-type">property</div><span>&nbsp;</span><span>this.$get</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Returns the actual instance of the $tooltip service.<br />TODO support multiple triggers</p></div>
          <pre><code class="language-javascript">this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
  var openedTooltips = $$stackedMap.createNew();
  $document.on('keyup', keypressListener);

  $rootScope.$on('$destroy', function() {
    $document.off('keyup', keypressListener);
  });

  function keypressListener(e) {
    if (e.which === 27) {
      var last = openedTooltips.top();
      if (last) {
        last.value.close();
        last = null;
      }
    }
  }

  return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
    options = angular.extend({}, defaultOptions, globalOptions, options);</code></pre>
          <section id="getTriggers">
            <h1>getTriggers</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>getTriggers()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Returns an object of show and hide triggers.</p><p>If a trigger is supplied,<br />it is used to show the tooltip; otherwise, it will use the <code>trigger</code><br />option passed to the <code>$tooltipProvider.options</code> method; else it will<br />default to the trigger supplied to this directive factory.</p><p>The hide trigger is based on the show trigger. If the <code>trigger</code> option<br />was passed to the <code>$tooltipProvider.options</code> method, it will use the<br />mapped trigger from <code>triggerMap</code> or the passed trigger if the map is<br />undefined; otherwise, it uses the <code>triggerMap</code> value of the show<br />trigger; else it will just use the show trigger.</p></div>
          <pre><code class="language-javascript">function getTriggers(trigger) {
  var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
  var hide = show.map(function(trigger) {
    return triggerMap[trigger] || trigger;
  });
  return {
    show: show,
    hide: hide
  };
}

var directiveName = snake_case(ttType);

var startSym = $interpolate.startSymbol();
var endSym = $interpolate.endSymbol();
var template =
  '&lt;div '+ directiveName + '-popup ' +
    'uib-title=&quot;' + startSym + 'title' + endSym + '&quot; ' +
    (options.useContentExp ?
      'content-exp=&quot;contentExp()&quot; ' :
      'content=&quot;' + startSym + 'content' + endSym + '&quot; ') +
    'origin-scope=&quot;origScope&quot; ' +
    'class=&quot;uib-position-measure ' + prefix + '&quot; ' +
    'tooltip-animation-class=&quot;fade&quot;' +
    'uib-tooltip-classes ' +
    'ng-class=&quot;{ in: isOpen }&quot; ' +
    '&gt;' +
  '&lt;/div&gt;';

return {
  compile: function(tElem, tAttrs) {
    var tooltipLinker = $compile(template);

    return function link(scope, element, attrs, tooltipCtrl) {
      var tooltip;
      var tooltipLinkedScope;
      var transitionTimeout;
      var showTimeout;
      var hideTimeout;
      var positionTimeout;
      var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
      var triggers = getTriggers(undefined);
      var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
      var ttScope = scope.$new(true);
      var repositionScheduled = false;
      var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
      var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
      var observers = [];
      var lastPlacement;

      var positionTooltip = function() {
        // check if tooltip exists and is not empty
        if (!tooltip || !tooltip.html()) { return; }

        if (!positionTimeout) {
          positionTimeout = $timeout(function() {
            var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
            var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
            var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
            tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
            var placementClasses = ttPosition.placement.split('-');

            if (!tooltip.hasClass(placementClasses[0])) {
              tooltip.removeClass(lastPlacement.split('-')[0]);
              tooltip.addClass(placementClasses[0]);
            }

            if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
              tooltip.removeClass(options.placementClassPrefix + lastPlacement);
              tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
            }

            $timeout(function() {
              var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
              var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
              if (adjustment) {
                tooltip.css(adjustment);
              }
            }, 0, false);

            // first time through tt element will have the
            // uib-position-measure class or if the placement
            // has changed we need to position the arrow.
            if (tooltip.hasClass('uib-position-measure')) {
              $position.positionArrow(tooltip, ttPosition.placement);
              tooltip.removeClass('uib-position-measure');
            } else if (lastPlacement !== ttPosition.placement) {
              $position.positionArrow(tooltip, ttPosition.placement);
            }
            lastPlacement = ttPosition.placement;

            positionTimeout = null;
          }, 0, false);
        }
      };

      // Set up the correct scope to allow transclusion later
      ttScope.origScope = scope;

      // By default, the tooltip is not open.
      // TODO add ability to start tooltip opened
      ttScope.isOpen = false;

      function toggleTooltipBind() {
        if (!ttScope.isOpen) {
          showTooltipBind();
        } else {
          hideTooltipBind();
        }
      }

      // Show the tooltip with delay if specified, otherwise show it immediately
      function showTooltipBind() {
        if (hasEnableExp &amp;&amp; !scope.$eval(attrs[prefix + 'Enable'])) {
          return;
        }

        cancelHide();
        prepareTooltip();

        if (ttScope.popupDelay) {
          // Do nothing if the tooltip was already scheduled to pop-up.
          // This happens if show is triggered multiple times before any hide is triggered.
          if (!showTimeout) {
            showTimeout = $timeout(show, ttScope.popupDelay, false);
          }
        } else {
          show();
        }
      }

      function hideTooltipBind() {
        cancelShow();

        if (ttScope.popupCloseDelay) {
          if (!hideTimeout) {
            hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
          }
        } else {
          hide();
        }
      }

      // Show the tooltip popup element.
      function show() {
        cancelShow();
        cancelHide();

        // Don't show empty tooltips.
        if (!ttScope.content) {
          return angular.noop;
        }

        createTooltip();

        // And show the tooltip.
        ttScope.$evalAsync(function() {
          ttScope.isOpen = true;
          assignIsOpen(true);
          positionTooltip();
        });
      }

      function cancelShow() {
        if (showTimeout) {
          $timeout.cancel(showTimeout);
          showTimeout = null;
        }

        if (positionTimeout) {
          $timeout.cancel(positionTimeout);
          positionTimeout = null;
        }
      }

      // Hide the tooltip popup element.
      function hide() {
        if (!ttScope) {
          return;
        }

        // First things first: we don't show it anymore.
        ttScope.$evalAsync(function() {
          if (ttScope) {
            ttScope.isOpen = false;
            assignIsOpen(false);
            // And now we remove it from the DOM. However, if we have animation, we
            // need to wait for it to expire beforehand.
            // FIXME: this is a placeholder for a port of the transitions library.
            // The fade transition in TWBS is 150ms.
            if (ttScope.animation) {
              if (!transitionTimeout) {
                transitionTimeout = $timeout(removeTooltip, 150, false);
              }
            } else {
              removeTooltip();
            }
          }
        });
      }

      function cancelHide() {
        if (hideTimeout) {
          $timeout.cancel(hideTimeout);
          hideTimeout = null;
        }

        if (transitionTimeout) {
          $timeout.cancel(transitionTimeout);
          transitionTimeout = null;
        }
      }

      function createTooltip() {
        // There can only be one tooltip element per directive shown at once.
        if (tooltip) {
          return;
        }

        tooltipLinkedScope = ttScope.$new();
        tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
          if (appendToBody) {
            $document.find('body').append(tooltip);
          } else {
            element.after(tooltip);
          }
        });

        openedTooltips.add(ttScope, {
          close: hide
        });

        prepObservers();
      }

      function removeTooltip() {
        cancelShow();
        cancelHide();
        unregisterObservers();

        if (tooltip) {
          tooltip.remove();
          tooltip = null;
        }

        openedTooltips.remove(ttScope);
        
        if (tooltipLinkedScope) {
          tooltipLinkedScope.$destroy();
          tooltipLinkedScope = null;
        }
      }</code></pre>
          <section id="prepareTooltip">
            <h1>prepareTooltip</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>prepareTooltip()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Set the initial scope values. Once<br />the tooltip is created, the observers<br />will be added to keep things in sync.</p></div>
          <pre><code class="language-javascript">function prepareTooltip() {
  ttScope.title = attrs[prefix + 'Title'];
  if (contentParse) {
    ttScope.content = contentParse(scope);
  } else {
    ttScope.content = attrs[ttType];
  }

  ttScope.popupClass = attrs[prefix + 'Class'];
  ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
  var placement = $position.parsePlacement(ttScope.placement);
  lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

  var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
  var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
  ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
  ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
}

function assignIsOpen(isOpen) {
  if (isOpenParse &amp;&amp; angular.isFunction(isOpenParse.assign)) {
    isOpenParse.assign(scope, isOpen);
  }
}

ttScope.contentExp = function() {
  return ttScope.content;
};</code></pre>
          <div class="description"><p>Observe the relevant attributes.</p></div>
          <pre><code class="language-javascript">attrs.$observe('disabled', function(val) {
  if (val) {
    cancelShow();
  }

  if (val &amp;&amp; ttScope.isOpen) {
    hide();
  }
});

if (isOpenParse) {
  scope.$watch(isOpenParse, function(val) {
    if (ttScope &amp;&amp; !val === ttScope.isOpen) {
      toggleTooltipBind();
    }
  });
}

function prepObservers() {
  observers.length = 0;

  if (contentParse) {
    observers.push(
      scope.$watch(contentParse, function(val) {
        ttScope.content = val;
        if (!val &amp;&amp; ttScope.isOpen) {
          hide();
        }
      })
    );

    observers.push(
      tooltipLinkedScope.$watch(function() {
        if (!repositionScheduled) {
          repositionScheduled = true;
          tooltipLinkedScope.$$postDigest(function() {
            repositionScheduled = false;
            if (ttScope &amp;&amp; ttScope.isOpen) {
              positionTooltip();
            }
          });
        }
      })
    );
  } else {
    observers.push(
      attrs.$observe(ttType, function(val) {
        ttScope.content = val;
        if (!val &amp;&amp; ttScope.isOpen) {
          hide();
        } else {
          positionTooltip();
        }
      })
    );
  }

  observers.push(
    attrs.$observe(prefix + 'Title', function(val) {
      ttScope.title = val;
      if (ttScope.isOpen) {
        positionTooltip();
      }
    })
  );

  observers.push(
    attrs.$observe(prefix + 'Placement', function(val) {
      ttScope.placement = val ? val : options.placement;
      if (ttScope.isOpen) {
        positionTooltip();
      }
    })
  );
}

function unregisterObservers() {
  if (observers.length) {
    angular.forEach(observers, function(observer) {
      observer();
    });
    observers.length = 0;
  }
}

// hide tooltips/popovers for outsideClick trigger
function bodyHideTooltipBind(e) {
  if (!ttScope || !ttScope.isOpen || !tooltip) {
    return;
  }
  // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
  if (!element[0].contains(e.target) &amp;&amp; !tooltip[0].contains(e.target)) {
    hideTooltipBind();
  }
}

var unregisterTriggers = function() {
  triggers.show.forEach(function(trigger) {
    if (trigger === 'outsideClick') {
      element.off('click', toggleTooltipBind);
    } else {
      element.off(trigger, showTooltipBind);
      element.off(trigger, toggleTooltipBind);
    }
  });
  triggers.hide.forEach(function(trigger) {
    if (trigger === 'outsideClick') {
      $document.off('click', bodyHideTooltipBind);
    } else {
      element.off(trigger, hideTooltipBind);
    }
  });
};

function prepTriggers() {
  var showTriggers = [], hideTriggers = [];
  var val = scope.$eval(attrs[prefix + 'Trigger']);
  unregisterTriggers();

  if (angular.isObject(val)) {
    Object.keys(val).forEach(function(key) {
      showTriggers.push(key);
      hideTriggers.push(val[key]);
    });
    triggers = {
      show: showTriggers,
      hide: hideTriggers
    };
  } else {
    triggers = getTriggers(val);
  }

  if (triggers.show !== 'none') {
    triggers.show.forEach(function(trigger, idx) {
      if (trigger === 'outsideClick') {
        element.on('click', toggleTooltipBind);
        $document.on('click', bodyHideTooltipBind);
      } else if (trigger === triggers.hide[idx]) {
        element.on(trigger, toggleTooltipBind);
      } else if (trigger) {
        element.on(trigger, showTooltipBind);
        element.on(triggers.hide[idx], hideTooltipBind);
      }

      element.on('keypress', function(e) {
        if (e.which === 27) {
          hideTooltipBind();
        }
      });
    });
  }
}

prepTriggers();

var animation = scope.$eval(attrs[prefix + 'Animation']);
ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

var appendToBodyVal;
var appendKey = prefix + 'AppendToBody';
if (appendKey in attrs &amp;&amp; attrs[appendKey] === undefined) {
  appendToBodyVal = true;
} else {
  appendToBodyVal = scope.$eval(attrs[appendKey]);
}

appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

// Make sure tooltip is destroyed and removed.
scope.$on('$destroy', function onDestroyTooltip() {
  unregisterTriggers();
  removeTooltip();
  ttScope = null;
});
          };
        }
      };
    };
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive('uibTooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest',
function ($animate, $sce, $compile, $templateRequest) {
  return {
    link: function(scope, elem, attrs) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }

        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }

        if (currentElement) {
          $animate.leave(currentElement).then(function() {
previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
if (thisChangeId !== changeCounter) { return; }
var newScope = origScope.$new();
var template = response;

var clone = $compile(template)(newScope, function(clone) {
  cleanupLastIncludeContent();
  $animate.enter(clone, elem);
});

currentScope = newScope;
currentElement = clone;

currentScope.$emit('$includeContentLoaded', src);
          }, function() {
if (thisChangeId === changeCounter) {
  cleanupLastIncludeContent();
  scope.$emit('$includeContentError', src);
}
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])</code></pre>
          <div class="description"><p>Note that it&#39;s intentional that these classes are <em>not</em> applied through $animate.<br />They must not be animated as they&#39;re expected to be present on the tooltip on<br />initialization.</p></div>
          <pre><code class="language-javascript">.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      // need to set the primary position so the
      // arrow has space during position measure.
      // tooltip.positionTooltip()
      if (scope.placement) {
        // // There are no top-left etc... classes
        // // in TWBS, so we need the primary position.
        var position = $uibPosition.parsePlacement(scope.placement);
        element.addClass(position[0]);
      }

      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }

      if (scope.animation) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
}])

.directive('uibTooltipPopup', function() {
  return {
    restrict: 'A',
    scope: { content: '@' },
    templateUrl: 'uib/template/tooltip/tooltip-popup.html'
  };
})

.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
}])

.directive('uibTooltipTemplatePopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&amp;', originScope: '&amp;' },
    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
  };
})

.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive('uibTooltipHtmlPopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&amp;' },
    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
  };
})

.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}]);</code></pre>
          <div class="description"><p>The following features are still outstanding: popup delay, animation as a<br />function, placement as a function, inside, support for more triggers than<br />just mouse enter/leave, and selector delegatation.</p></div>
          <pre><code class="language-javascript">angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

.directive('uibPopoverTemplatePopup', function() {
  return {
    restrict: 'A',
    scope: { uibTitle: '@', contentExp: '&amp;', originScope: '&amp;' },
    templateUrl: 'uib/template/popover/popover-template.html'
  };
})

.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverHtmlPopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&amp;', uibTitle: '@' },
    templateUrl: 'uib/template/popover/popover-html.html'
  };
})

.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverPopup', function() {
  return {
    restrict: 'A',
    scope: { uibTitle: '@', content: '@' },
    templateUrl: 'uib/template/popover/popover.html'
  };
})

.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopover', 'popover', 'click');
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('uibProgressConfig', {
  animate: true,
  max: 100
})

.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
  var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = getMaxOrDefault();

  this.addBar = function(bar, element, attrs) {
    if (!animate) {
      element.css({'transition': 'none'});
    }

    this.bars.push(bar);

    bar.max = getMaxOrDefault();
    bar.title = attrs &amp;&amp; angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

    bar.$watch('value', function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      var totalPercentage = self.bars.reduce(function(total, bar) {
        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
        return total + bar.percent;
      }, 0);

      if (totalPercentage &gt; 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on('$destroy', function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
    this.bars.splice(this.bars.indexOf(bar), 1);
    this.bars.forEach(function (bar) {
      bar.recalculatePercentage();
    });
  };

  //$attrs.$observe('maxParam', function(maxParam) {
  $scope.$watch('maxParam', function(maxParam) {
    self.bars.forEach(function(bar) {
      bar.max = getMaxOrDefault();
      bar.recalculatePercentage();
    });
  });

  function getMaxOrDefault () {
    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
  }
}])

.directive('uibProgress', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    require: 'uibProgress',
    scope: {
      maxParam: '=?max'
    },
    templateUrl: 'uib/template/progressbar/progress.html'
  };
})

.directive('uibBar', function() {
  return {
    replace: true,
    transclude: true,
    require: '^uibProgress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'uib/template/progressbar/bar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, element, attrs);
    }
  };
})

.directive('uibProgressbar', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    scope: {
      value: '=',
      maxParam: '=?max',
      type: '@'
    },
    templateUrl: 'uib/template/progressbar/progressbar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
    }
  };
});

angular.module('ui.bootstrap.rating', [])

.constant('uibRatingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null,
  enableReset: true,
  titles: ['one', 'two', 'three', 'four', 'five']
})

.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl = { $setViewValue: angular.noop },
    self = this;

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) &amp;&amp; value &lt;&lt; 0 !== value) {
        value = Math.round(value);
      }

      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    this.enableReset = angular.isDefined($attrs.enableReset) ?
      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
    this.titles = angular.isArray(tmpTitles) &amp;&amp; tmpTitles.length &gt; 0 ?
      tmpTitles : ratingConfig.titles;

    var ratingStates = angular.isDefined($attrs.ratingStates) ?
      $scope.$parent.$eval($attrs.ratingStates) :
      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i &lt; n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
    }
    return states;
  };

  this.getTitle = function(index) {
    if (index &gt;= this.titles.length) {
      return index + 1;
    }

    return this.titles[index];
  };

  $scope.rate = function(value) {
    if (!$scope.readonly &amp;&amp; value &gt;= 0 &amp;&amp; value &lt;= $scope.range.length) {
      var newViewValue = self.enableReset &amp;&amp; ngModelCtrl.$viewValue === value ? 0 : value;
      ngModelCtrl.$setViewValue(newViewValue);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if (!$scope.readonly) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.title = self.getTitle($scope.value - 1);
  };
}])

.directive('uibRating', function() {
  return {
    require: ['uibRating', 'ngModel'],
    restrict: 'A',
    scope: {
      readonly: '=?readOnly',
      onHover: '&amp;',
      onLeave: '&amp;'
    },
    controller: 'UibRatingController',
    templateUrl: 'uib/template/rating/rating.html',
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init(ngModelCtrl);
    }
  };
});

angular.module('ui.bootstrap.tabs', [])

.controller('UibTabsetController', ['$scope', function ($scope) {
  var ctrl = this,
    oldIndex;
  ctrl.tabs = [];

  ctrl.select = function(index, evt) {
    if (!destroyed) {
      var previousIndex = findTabIndex(oldIndex);
      var previousSelected = ctrl.tabs[previousIndex];
      if (previousSelected) {
        previousSelected.tab.onDeselect({
          $event: evt,
          $selectedIndex: index
        });
        if (evt &amp;&amp; evt.isDefaultPrevented()) {
          return;
        }
        previousSelected.tab.active = false;
      }

      var selected = ctrl.tabs[index];
      if (selected) {
        selected.tab.onSelect({
          $event: evt
        });
        selected.tab.active = true;
        ctrl.active = selected.index;
        oldIndex = selected.index;
      } else if (!selected &amp;&amp; angular.isDefined(oldIndex)) {
        ctrl.active = null;
        oldIndex = null;
      }
    }
  };

  ctrl.addTab = function addTab(tab) {
    ctrl.tabs.push({
      tab: tab,
      index: tab.index
    });
    ctrl.tabs.sort(function(t1, t2) {
      if (t1.index &gt; t2.index) {
        return 1;
      }

      if (t1.index &lt; t2.index) {
        return -1;
      }

      return 0;
    });

    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) &amp;&amp; ctrl.tabs.length === 1) {
      var newActiveIndex = findTabIndex(tab.index);
      ctrl.select(newActiveIndex);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index;
    for (var i = 0; i &lt; ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].tab === tab) {
        index = i;
        break;
      }
    }

    if (ctrl.tabs[index].index === ctrl.active) {
      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
        index - 1 : index + 1 % ctrl.tabs.length;
      ctrl.select(newActiveTabIndex);
    }

    ctrl.tabs.splice(index, 1);
  };

  $scope.$watch('tabset.active', function(val) {
    if (angular.isDefined(val) &amp;&amp; val !== oldIndex) {
      ctrl.select(findTabIndex(val));
    }
  });

  var destroyed;
  $scope.$on('$destroy', function() {
    destroyed = true;
  });

  function findTabIndex(index) {
    for (var i = 0; i &lt; ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].index === index) {
        return i;
      }
    }
  }
}])

.directive('uibTabset', function() {
  return {
    transclude: true,
    replace: true,
    scope: {},
    bindToController: {
      active: '=?',
      type: '@'
    },
    controller: 'UibTabsetController',
    controllerAs: 'tabset',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/tabs/tabset.html';
    },
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ?
        scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ?
        scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

.directive('uibTab', ['$parse', function($parse) {
  return {
    require: '^uibTabset',
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/tabs/tab.html';
    },
    transclude: true,
    scope: {
      heading: '@',
      index: '=?',
      classes: '@?',
      onSelect: '&amp;select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&amp;deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    controllerAs: 'tab',
    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
      scope.disabled = false;
      if (attrs.disable) {
        scope.$parent.$watch($parse(attrs.disable), function(value) {
          scope.disabled = !! value;
        });
      }

      if (angular.isUndefined(attrs.index)) {
        if (tabsetCtrl.tabs &amp;&amp; tabsetCtrl.tabs.length) {
          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;
        } else {
          scope.index = 0;
        }
      }

      if (angular.isUndefined(attrs.classes)) {
        scope.classes = '';
      }

      scope.select = function(evt) {
        if (!scope.disabled) {
          var index;
          for (var i = 0; i &lt; tabsetCtrl.tabs.length; i++) {
            if (tabsetCtrl.tabs[i].tab === scope) {
              index = i;
              break;
            }
          }

          tabsetCtrl.select(index, evt);
        }
      };

      tabsetCtrl.addTab(scope);
      scope.$on('$destroy', function() {
        tabsetCtrl.removeTab(scope);
      });

      //We need to transclude later, once the content container is ready.
      //when this link happens, we're inside a tab heading.
      scope.$transcludeFn = transclude;
    }
  };
}])

.directive('uibTabHeadingTransclude', function() {
  return {
    restrict: 'A',
    require: '^uibTab',
    link: function(scope, elm) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
})

.directive('uibTabContentTransclude', function() {
  return {
    restrict: 'A',
    require: '^uibTabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };

  function isTabHeading(node) {
    return node.tagName &amp;&amp; (
      node.hasAttribute('uib-tab-heading') ||
      node.hasAttribute('data-uib-tab-heading') ||
      node.hasAttribute('x-uib-tab-heading') ||
      node.tagName.toLowerCase() === 'uib-tab-heading' ||
      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'uib:tab-heading'
    );
  }
});

angular.module('ui.bootstrap.timepicker', [])

.constant('uibTimepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  secondStep: 1,
  showMeridian: true,
  showSeconds: false,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true,
  showSpinners: true,
  templateUrl: 'uib/template/timepicker/timepicker.html'
})

.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
    watchers = [],
    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
  $element.removeAttr('tabindex');

  this.init = function(ngModelCtrl_, inputs) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function(modelValue) {
      return modelValue ? new Date(modelValue) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1),
        secondsInputEl = inputs.eq(2);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

    if (mousewheel) {
      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = +value;
    }));
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = +value;
    }));
  }

  var min;
  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
    var dt = new Date(value);
    min = isNaN(dt) ? undefined : dt;
  }));

  var max;
  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
    var dt = new Date(value);
    max = isNaN(dt) ? undefined : dt;
  }));

  var disabled = false;
  if ($attrs.ngDisabled) {
    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
      disabled = value;
    }));
  }

  $scope.noIncrementHours = function() {
    var incrementedSelected = addMinutes(selected, hourStep * 60);
    return disabled || incrementedSelected &gt; max ||
      incrementedSelected &lt; selected &amp;&amp; incrementedSelected &lt; min;
  };

  $scope.noDecrementHours = function() {
    var decrementedSelected = addMinutes(selected, -hourStep * 60);
    return disabled || decrementedSelected &lt; min ||
      decrementedSelected &gt; selected &amp;&amp; decrementedSelected &gt; max;
  };

  $scope.noIncrementMinutes = function() {
    var incrementedSelected = addMinutes(selected, minuteStep);
    return disabled || incrementedSelected &gt; max ||
      incrementedSelected &lt; selected &amp;&amp; incrementedSelected &lt; min;
  };

  $scope.noDecrementMinutes = function() {
    var decrementedSelected = addMinutes(selected, -minuteStep);
    return disabled || decrementedSelected &lt; min ||
      decrementedSelected &gt; selected &amp;&amp; decrementedSelected &gt; max;
  };

  $scope.noIncrementSeconds = function() {
    var incrementedSelected = addSeconds(selected, secondStep);
    return disabled || incrementedSelected &gt; max ||
      incrementedSelected &lt; selected &amp;&amp; incrementedSelected &lt; min;
  };

  $scope.noDecrementSeconds = function() {
    var decrementedSelected = addSeconds(selected, -secondStep);
    return disabled || decrementedSelected &lt; min ||
      decrementedSelected &gt; selected &amp;&amp; decrementedSelected &gt; max;
  };

  $scope.noToggleMeridian = function() {
    if (selected.getHours() &lt; 12) {
      return disabled || addMinutes(selected, 12 * 60) &gt; max;
    }

    return disabled || addMinutes(selected, -12 * 60) &lt; min;
  };

  var secondStep = timepickerConfig.secondStep;
  if ($attrs.secondStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
      secondStep = +value;
    }));
  }

  $scope.showSeconds = timepickerConfig.showSeconds;
  if ($attrs.showSeconds) {
    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
      $scope.showSeconds = !!value;
    }));
  }

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if (ngModelCtrl.$error.time) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined(hours) &amp;&amp; angular.isDefined(minutes)) {
          selected.setHours(hours);
          refresh();
        }
      } else {
        updateTemplate();
      }
    }));
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate() {
    var hours = +$scope.hours;
    var valid = $scope.showMeridian ? hours &gt; 0 &amp;&amp; hours &lt; 13 :
      hours &gt;= 0 &amp;&amp; hours &lt; 24;
    if (!valid || $scope.hours === '') {
      return undefined;
    }

    if ($scope.showMeridian) {
      if (hours === 12) {
        hours = 0;
      }
      if ($scope.meridian === meridians[1]) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = +$scope.minutes;
    var valid = minutes &gt;= 0 &amp;&amp; minutes &lt; 60;
    if (!valid || $scope.minutes === '') {
      return undefined;
    }
    return minutes;
  }

  function getSecondsFromTemplate() {
    var seconds = +$scope.seconds;
    return seconds &gt;= 0 &amp;&amp; seconds &lt; 60 ? seconds : undefined;
  }

  function pad(value, noPad) {
    if (value === null) {
      return '';
    }

    return angular.isDefined(value) &amp;&amp; value.toString().length &lt; 2 &amp;&amp; !noPad ?
      '0' + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
      return e.detail || delta &gt; 0;
    };

    hoursInputEl.bind('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
      }
      e.preventDefault();
    });

    minutesInputEl.bind('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
      }
      e.preventDefault();
    });

     secondsInputEl.bind('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
      }
      e.preventDefault();
    });
  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    hoursInputEl.bind('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementHours();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementHours();
          $scope.$apply();
        }
      }
    });

    minutesInputEl.bind('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementMinutes();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementMinutes();
          $scope.$apply();
        }
      }
    });

    secondsInputEl.bind('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementSeconds();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementSeconds();
          $scope.$apply();
        }
      }
    });
  };

  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    if ($scope.readonlyInput) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      $scope.updateSeconds = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
      ngModelCtrl.$setViewValue(null);
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }

      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }

      if (angular.isDefined(invalidSeconds)) {
        $scope.invalidSeconds = invalidSeconds;
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate(),
        minutes = getMinutesFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(hours) &amp;&amp; angular.isDefined(minutes)) {
        selected.setHours(hours);
        selected.setMinutes(minutes);
        if (selected &lt; min || selected &gt; max) {
          invalidate(true);
        } else {
          refresh('h');
        }
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind('blur', function(e) {
      ngModelCtrl.$setTouched();
      if (modelIsEmpty()) {
        makeValid();
      } else if ($scope.hours === null || $scope.hours === '') {
        invalidate(true);
      } else if (!$scope.invalidHours &amp;&amp; $scope.hours &lt; 10) {
        $scope.$apply(function() {
          $scope.hours = pad($scope.hours, !padHours);
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(minutes) &amp;&amp; angular.isDefined(hours)) {
        selected.setHours(hours);
        selected.setMinutes(minutes);
        if (selected &lt; min || selected &gt; max) {
          invalidate(undefined, true);
        } else {
          refresh('m');
        }
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind('blur', function(e) {
      ngModelCtrl.$setTouched();
      if (modelIsEmpty()) {
        makeValid();
      } else if ($scope.minutes === null) {
        invalidate(undefined, true);
      } else if (!$scope.invalidMinutes &amp;&amp; $scope.minutes &lt; 10) {
        $scope.$apply(function() {
          $scope.minutes = pad($scope.minutes);
        });
      }
    });

    $scope.updateSeconds = function() {
      var seconds = getSecondsFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(seconds)) {
        selected.setSeconds(seconds);
        refresh('s');
      } else {
        invalidate(undefined, undefined, true);
      }
    };

    secondsInputEl.bind('blur', function(e) {
      if (modelIsEmpty()) {
        makeValid();
      } else if (!$scope.invalidSeconds &amp;&amp; $scope.seconds &lt; 10) {
        $scope.$apply( function() {
          $scope.seconds = pad($scope.seconds);
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if (isNaN(date)) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: &quot;ng-model&quot; value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if (date) {
        selected = date;
      }

      if (selected &lt; min || selected &gt; max) {
        ngModelCtrl.$setValidity('time', false);
        $scope.invalidHours = true;
        $scope.invalidMinutes = true;
      } else {
        makeValid();
      }
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh(keyboardChange) {
    makeValid();
    ngModelCtrl.$setViewValue(new Date(selected));
    updateTemplate(keyboardChange);
  }

  function makeValid() {
    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
    $scope.invalidSeconds = false;
  }

  function updateTemplate(keyboardChange) {
    if (!ngModelCtrl.$modelValue) {
      $scope.hours = null;
      $scope.minutes = null;
      $scope.seconds = null;
      $scope.meridian = meridians[0];
    } else {
      var hours = selected.getHours(),
        minutes = selected.getMinutes(),
        seconds = selected.getSeconds();

      if ($scope.showMeridian) {
        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
      }

      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
      if (keyboardChange !== 'm') {
        $scope.minutes = pad(minutes);
      }
      $scope.meridian = selected.getHours() &lt; 12 ? meridians[0] : meridians[1];

      if (keyboardChange !== 's') {
        $scope.seconds = pad(seconds);
      }
      $scope.meridian = selected.getHours() &lt; 12 ? meridians[0] : meridians[1];
    }
  }

  function addSecondsToSelected(seconds) {
    selected = addSeconds(selected, seconds);
    refresh();
  }

  function addMinutes(selected, minutes) {
    return addSeconds(selected, minutes*60);
  }

  function addSeconds(date, seconds) {
    var dt = new Date(date.getTime() + seconds * 1000);
    var newDate = new Date(date);
    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
    return newDate;
  }

  function modelIsEmpty() {
    return ($scope.hours === null || $scope.hours === '') &amp;&amp;
      ($scope.minutes === null || $scope.minutes === '') &amp;&amp;
      (!$scope.showSeconds || $scope.showSeconds &amp;&amp; ($scope.seconds === null || $scope.seconds === ''));
  }

  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

  $scope.incrementHours = function() {
    if (!$scope.noIncrementHours()) {
      addSecondsToSelected(hourStep * 60 * 60);
    }
  };

  $scope.decrementHours = function() {
    if (!$scope.noDecrementHours()) {
      addSecondsToSelected(-hourStep * 60 * 60);
    }
  };

  $scope.incrementMinutes = function() {
    if (!$scope.noIncrementMinutes()) {
      addSecondsToSelected(minuteStep * 60);
    }
  };

  $scope.decrementMinutes = function() {
    if (!$scope.noDecrementMinutes()) {
      addSecondsToSelected(-minuteStep * 60);
    }
  };

  $scope.incrementSeconds = function() {
    if (!$scope.noIncrementSeconds()) {
      addSecondsToSelected(secondStep);
    }
  };

  $scope.decrementSeconds = function() {
    if (!$scope.noDecrementSeconds()) {
      addSecondsToSelected(-secondStep);
    }
  };

  $scope.toggleMeridian = function() {
    var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

    if (!$scope.noToggleMeridian()) {
      if (angular.isDefined(minutes) &amp;&amp; angular.isDefined(hours)) {
        addSecondsToSelected(12 * 60 * (selected.getHours() &lt; 12 ? 60 : -60));
      } else {
        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
      }
    }
  };

  $scope.blur = function() {
    ngModelCtrl.$setTouched();
  };

  $scope.$on('$destroy', function() {
    while (watchers.length) {
      watchers.shift()();
    }
  });
}])

.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
  return {
    require: ['uibTimepicker', '?^ngModel'],
    restrict: 'A',
    controller: 'UibTimepickerController',
    controllerAs: 'timepicker',
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || uibTimepickerConfig.templateUrl;
    },
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])</code></pre>
          <div class="description"><p>A helper service that can parse typeahead&#39;s syntax (string provided by users)<br />Extracted to a separate service for ease of unit testing</p></div>
          <pre><code class="language-javascript">.factory('uibTypeaheadParser', ['$parse', function($parse) {
  //                      000001111111100000000000002222222200000000000000003333333333333330000000000044444444000
  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
  return {
    parse: function(input) {
      var match = input.match(TYPEAHEAD_REGEXP);
      if (!match) {
        throw new Error(
          'Expected typeahead specification in form of &quot;_modelValue_ (as _label_)? for _item_ in _collection_&quot;' +
            ' but got &quot;' + input + '&quot;.');
      }

      return {
        itemName: match[3],
        source: $parse(match[4]),
        viewMapper: $parse(match[2] || match[1]),
        modelMapper: $parse(match[1])
      };
    }
  };
}])

.controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
  function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
  var HOT_KEYS = [9, 13, 27, 38, 40];
  var eventDebounceTime = 200;
  var modelCtrl, ngModelOptions;
  //SUPPORTED ATTRIBUTES (OPTIONS)

  //minimal no of characters that needs to be entered before typeahead kicks-in
  var minLength = originalScope.$eval(attrs.typeaheadMinLength);
  if (!minLength &amp;&amp; minLength !== 0) {
    minLength = 1;
  }

  originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
      minLength = !newVal &amp;&amp; newVal !== 0 ? 1 : newVal;
  });

  //minimal wait time after last character typed before typeahead kicks-in
  var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

  //should it restrict model values to the ones selected from the popup only?
  var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
  originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
    isEditable = newVal !== false;
  });

  //binding to a variable that indicates if matches are being retrieved asynchronously
  var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

  //a function to determine if an event should cause selection
  var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
    var evt = vals.$event;
    return evt.which === 13 || evt.which === 9;
  };

  //a callback executed when a match is selected
  var onSelectCallback = $parse(attrs.typeaheadOnSelect);

  //should it select highlighted popup value when losing focus?
  var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

  //binding to a variable that indicates if there were no results after the query is completed
  var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

  var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

  var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

  var appendTo = attrs.typeaheadAppendTo ?
    originalScope.$eval(attrs.typeaheadAppendTo) : null;

  var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

  //If input matches an item of the list exactly, select it automatically
  var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

  //binding to a variable that indicates if dropdown is open
  var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

  var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

  //INTERNAL VARIABLES

  //model setter executed upon match selection
  var parsedModel = $parse(attrs.ngModel);
  var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
  var $setModelValue = function(scope, newValue) {
    if (angular.isFunction(parsedModel(originalScope)) &amp;&amp;
      ngModelOptions &amp;&amp; ngModelOptions.$options &amp;&amp; ngModelOptions.$options.getterSetter) {
      return invokeModelSetter(scope, {$$$p: newValue});
    }

    return parsedModel.assign(scope, newValue);
  };

  //expressions used by typeahead
  var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

  var hasFocus;

  //Used to avoid bug in iOS webview where iOS keyboard does not fire
  //mousedown &amp; mouseup events
  //Issue #3699
  var selected;

  //create a child scope for the typeahead directive so we are not polluting original scope
  //with typeahead-specific data (matches, query etc.)
  var scope = originalScope.$new();
  var offDestroy = originalScope.$on('$destroy', function() {
    scope.$destroy();
  });
  scope.$on('$destroy', offDestroy);

  // WAI-ARIA
  var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
  element.attr({
    'aria-autocomplete': 'list',
    'aria-expanded': false,
    'aria-owns': popupId
  });

  var inputsContainer, hintInputElem;
  //add read-only input to show hint
  if (showHint) {
    inputsContainer = angular.element('&lt;div&gt;&lt;/div&gt;');
    inputsContainer.css('position', 'relative');
    element.after(inputsContainer);
    hintInputElem = element.clone();
    hintInputElem.attr('placeholder', '');
    hintInputElem.attr('tabindex', '-1');
    hintInputElem.val('');
    hintInputElem.css({
      'position': 'absolute',
      'top': '0px',
      'left': '0px',
      'border-color': 'transparent',
      'box-shadow': 'none',
      'opacity': 1,
      'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
      'color': '#999'
    });
    element.css({
      'position': 'relative',
      'vertical-align': 'top',
      'background-color': 'transparent'
    });

    if (hintInputElem.attr('id')) {
      hintInputElem.removeAttr('id'); // remove duplicate id if present.
    }
    inputsContainer.append(hintInputElem);
    hintInputElem.after(element);
  }

  //pop-up element used to display matches
  var popUpEl = angular.element('&lt;div uib-typeahead-popup&gt;&lt;/div&gt;');
  popUpEl.attr({
    id: popupId,
    matches: 'matches',
    active: 'activeIdx',
    select: 'select(activeIdx, evt)',
    'move-in-progress': 'moveInProgress',
    query: 'query',
    position: 'position',
    'assign-is-open': 'assignIsOpen(isOpen)',
    debounce: 'debounceUpdate'
  });
  //custom item template
  if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
    popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
  }

  if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
    popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
  }

  var resetHint = function() {
    if (showHint) {
      hintInputElem.val('');
    }
  };

  var resetMatches = function() {
    scope.matches = [];
    scope.activeIdx = -1;
    element.attr('aria-expanded', false);
    resetHint();
  };

  var getMatchId = function(index) {
    return popupId + '-option-' + index;
  };

  // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
  // This attribute is added or removed automatically when the `activeIdx` changes.
  scope.$watch('activeIdx', function(index) {
    if (index &lt; 0) {
      element.removeAttr('aria-activedescendant');
    } else {
      element.attr('aria-activedescendant', getMatchId(index));
    }
  });

  var inputIsExactMatch = function(inputValue, index) {
    if (scope.matches.length &gt; index &amp;&amp; inputValue) {
      return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
    }

    return false;
  };

  var getMatchesAsync = function(inputValue, evt) {
    var locals = {$viewValue: inputValue};
    isLoadingSetter(originalScope, true);
    isNoResultsSetter(originalScope, false);
    $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
      //it might happen that several async queries were in progress if a user were typing fast
      //but we are interested only in responses that correspond to the current view value
      var onCurrentRequest = inputValue === modelCtrl.$viewValue;
      if (onCurrentRequest &amp;&amp; hasFocus) {
        if (matches &amp;&amp; matches.length &gt; 0) {
          scope.activeIdx = focusFirst ? 0 : -1;
          isNoResultsSetter(originalScope, false);
          scope.matches.length = 0;

          //transform labels
          for (var i = 0; i &lt; matches.length; i++) {
            locals[parserResult.itemName] = matches[i];
            scope.matches.push({
              id: getMatchId(i),
              label: parserResult.viewMapper(scope, locals),
              model: matches[i]
            });
          }

          scope.query = inputValue;
          //position pop-up with matches - we need to re-calculate its position each time we are opening a window
          //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
          //due to other elements being rendered
          recalculatePosition();

          element.attr('aria-expanded', true);

          //Select the single remaining option if user input matches
          if (selectOnExact &amp;&amp; scope.matches.length === 1 &amp;&amp; inputIsExactMatch(inputValue, 0)) {
            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
              $$debounce(function() {
                scope.select(0, evt);
              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
            } else {
              scope.select(0, evt);
            }
          }

          if (showHint) {
            var firstLabel = scope.matches[0].label;
            if (angular.isString(inputValue) &amp;&amp;
              inputValue.length &gt; 0 &amp;&amp;
              firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
              hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
            } else {
              hintInputElem.val('');
            }
          }
        } else {
          resetMatches();
          isNoResultsSetter(originalScope, true);
        }
      }
      if (onCurrentRequest) {
        isLoadingSetter(originalScope, false);
      }
    }, function() {
      resetMatches();
      isLoadingSetter(originalScope, false);
      isNoResultsSetter(originalScope, true);
    });
  };

  // bind events only if appendToBody params exist - performance feature
  if (appendToBody) {
    angular.element($window).on('resize', fireRecalculating);
    $document.find('body').on('scroll', fireRecalculating);
  }

  // Declare the debounced function outside recalculating for
  // proper debouncing
  var debouncedRecalculate = $$debounce(function() {
    // if popup is visible
    if (scope.matches.length) {
      recalculatePosition();
    }

    scope.moveInProgress = false;
  }, eventDebounceTime);

  // Default progress type
  scope.moveInProgress = false;

  function fireRecalculating() {
    if (!scope.moveInProgress) {
      scope.moveInProgress = true;
      scope.$digest();
    }

    debouncedRecalculate();
  }

  // recalculate actual position and set new values to scope
  // after digest loop is popup in right position
  function recalculatePosition() {
    scope.position = appendToBody ? $position.offset(element) : $position.position(element);
    scope.position.top += element.prop('offsetHeight');
  }

  //we need to propagate user's query so we can higlight matches
  scope.query = undefined;

  //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
  var timeoutPromise;

  var scheduleSearchWithTimeout = function(inputValue) {
    timeoutPromise = $timeout(function() {
      getMatchesAsync(inputValue);
    }, waitTime);
  };

  var cancelPreviousTimeout = function() {
    if (timeoutPromise) {
      $timeout.cancel(timeoutPromise);
    }
  };

  resetMatches();

  scope.assignIsOpen = function (isOpen) {
    isOpenSetter(originalScope, isOpen);
  };

  scope.select = function(activeIdx, evt) {
    //called from within the $digest() cycle
    var locals = {};
    var model, item;

    selected = true;
    locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
    model = parserResult.modelMapper(originalScope, locals);
    $setModelValue(originalScope, model);
    modelCtrl.$setValidity('editable', true);
    modelCtrl.$setValidity('parse', true);

    onSelectCallback(originalScope, {
      $item: item,
      $model: model,
      $label: parserResult.viewMapper(originalScope, locals),
      $event: evt
    });

    resetMatches();

    //return focus to the input element if a match was selected via a mouse click event
    // use timeout to avoid $rootScope:inprog error
    if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
      $timeout(function() { element[0].focus(); }, 0, false);
    }
  };

  //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
  element.on('keydown', function(evt) {
    //typeahead is open and an &quot;interesting&quot; key was pressed
    if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
      return;
    }

    var shouldSelect = isSelectEvent(originalScope, {$event: evt});</code></pre>
          <section id="if">
            <h1>if</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>if()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>if there&#39;s nothing selected (i.e. focusFirst) and enter or tab is hit<br />or<br />shift + tab is pressed to bring focus to the previous element<br />then clear the results</p></div>
          <pre><code class="language-javascript">if (scope.activeIdx === -1 &amp;&amp; shouldSelect || evt.which === 9 &amp;&amp; !!evt.shiftKey) {
  resetMatches();
  scope.$digest();
  return;
}

evt.preventDefault();
var target;
switch (evt.which) {
  case 27: // escape
    evt.stopPropagation();

    resetMatches();
    originalScope.$digest();
    break;
  case 38: // up arrow
    scope.activeIdx = (scope.activeIdx &gt; 0 ? scope.activeIdx : scope.matches.length) - 1;
    scope.$digest();
    target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
    target.parentNode.scrollTop = target.offsetTop;
    break;
  case 40: // down arrow
    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
    scope.$digest();
    target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
    target.parentNode.scrollTop = target.offsetTop;
    break;
  default:
    if (shouldSelect) {
      scope.$apply(function() {
        if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
          $$debounce(function() {
            scope.select(scope.activeIdx, evt);
          }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
        } else {
          scope.select(scope.activeIdx, evt);
        }
      });
    }
}
    });

    element.bind('focus', function (evt) {
hasFocus = true;
if (minLength === 0 &amp;&amp; !modelCtrl.$viewValue) {
  $timeout(function() {
    getMatchesAsync(modelCtrl.$viewValue, evt);
  }, 0);
}
    });

    element.bind('blur', function(evt) {
if (isSelectOnBlur &amp;&amp; scope.matches.length &amp;&amp; scope.activeIdx !== -1 &amp;&amp; !selected) {
  selected = true;
  scope.$apply(function() {
    if (angular.isObject(scope.debounceUpdate) &amp;&amp; angular.isNumber(scope.debounceUpdate.blur)) {
      $$debounce(function() {
        scope.select(scope.activeIdx, evt);
      }, scope.debounceUpdate.blur);
    } else {
      scope.select(scope.activeIdx, evt);
    }
  });
}
if (!isEditable &amp;&amp; modelCtrl.$error.editable) {
  modelCtrl.$setViewValue();
  scope.$apply(function() {
    // Reset validity as we are clearing
    modelCtrl.$setValidity('editable', true);
    modelCtrl.$setValidity('parse', true);
  });
  element.val('');
}
hasFocus = false;
selected = false;
    });

    // Keep reference to click handler to unbind it.
    var dismissClickHandler = function(evt) {
// Issue #3973
// Firefox treats right click as a click on document
if (element[0] !== evt.target &amp;&amp; evt.which !== 3 &amp;&amp; scope.matches.length !== 0) {
  resetMatches();
  if (!$rootScope.$$phase) {
    originalScope.$digest();
  }
}
    };

    $document.on('click', dismissClickHandler);

    originalScope.$on('$destroy', function() {
$document.off('click', dismissClickHandler);
if (appendToBody || appendTo) {
  $popup.remove();
}

if (appendToBody) {
  angular.element($window).off('resize', fireRecalculating);
  $document.find('body').off('scroll', fireRecalculating);
}
// Prevent jQuery cache memory leak
popUpEl.remove();

if (showHint) {
    inputsContainer.remove();
}
    });

    var $popup = $compile(popUpEl)(scope);

    if (appendToBody) {
$document.find('body').append($popup);
    } else if (appendTo) {
angular.element(appendTo).eq(0).append($popup);
    } else {
element.after($popup);
    }

    this.init = function(_modelCtrl, _ngModelOptions) {
modelCtrl = _modelCtrl;
ngModelOptions = _ngModelOptions;

scope.debounceUpdate = modelCtrl.$options &amp;&amp; $parse(modelCtrl.$options.debounce)(originalScope);

//plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
//$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
modelCtrl.$parsers.unshift(function(inputValue) {
  hasFocus = true;

  if (minLength === 0 || inputValue &amp;&amp; inputValue.length &gt;= minLength) {
    if (waitTime &gt; 0) {
      cancelPreviousTimeout();
      scheduleSearchWithTimeout(inputValue);
    } else {
      getMatchesAsync(inputValue);
    }
  } else {
    isLoadingSetter(originalScope, false);
    cancelPreviousTimeout();
    resetMatches();
  }

  if (isEditable) {
    return inputValue;
  }

  if (!inputValue) {
    // Reset in case user had typed something previously.
    modelCtrl.$setValidity('editable', true);
    return null;
  }

  modelCtrl.$setValidity('editable', false);
  return undefined;
});

modelCtrl.$formatters.push(function(modelValue) {
  var candidateViewValue, emptyViewValue;
  var locals = {};

  // The validity may be set to false via $parsers (see above) if
  // the model is restricted to selected values. If the model
  // is set manually it is considered to be valid.
  if (!isEditable) {
    modelCtrl.$setValidity('editable', true);
  }

  if (inputFormatter) {
    locals.$model = modelValue;
    return inputFormatter(originalScope, locals);
  }

  //it might happen that we don't have enough info to properly render input value
  //we need to check for this situation and simply return model value if we can't apply custom formatting
  locals[parserResult.itemName] = modelValue;
  candidateViewValue = parserResult.viewMapper(originalScope, locals);
  locals[parserResult.itemName] = undefined;
  emptyViewValue = parserResult.viewMapper(originalScope, locals);

  return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
});
    };
  }])

  .directive('uibTypeahead', function() {
    return {
controller: 'UibTypeaheadController',
require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
link: function(originalScope, element, attrs, ctrls) {
  ctrls[2].init(ctrls[0], ctrls[1]);
}
    };
  })

  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
    return {
scope: {
  matches: '=',
  query: '=',
  active: '=',
  position: '&amp;',
  moveInProgress: '=',
  select: '&amp;',
  assignIsOpen: '&amp;',
  debounce: '&amp;'
},
replace: true,
templateUrl: function(element, attrs) {
  return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
},
link: function(scope, element, attrs) {
  scope.templateUrl = attrs.templateUrl;

  scope.isOpen = function() {
    var isDropdownOpen = scope.matches.length &gt; 0;
    scope.assignIsOpen({ isOpen: isDropdownOpen });
    return isDropdownOpen;
  };

  scope.isActive = function(matchIdx) {
    return scope.active === matchIdx;
  };

  scope.selectActive = function(matchIdx) {
    scope.active = matchIdx;
  };

  scope.selectMatch = function(activeIdx, evt) {
    var debounce = scope.debounce();
    if (angular.isNumber(debounce) || angular.isObject(debounce)) {
      $$debounce(function() {
        scope.select({activeIdx: activeIdx, evt: evt});
      }, angular.isNumber(debounce) ? debounce : debounce['default']);
    } else {
      scope.select({activeIdx: activeIdx, evt: evt});
    }
  };
}
    };
  }])

  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
scope: {
  index: '=',
  match: '=',
  query: '='
},
link: function(scope, element, attrs) {
  var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
  $templateRequest(tplUrl).then(function(tplContent) {
    var tplEl = angular.element(tplContent.trim());
    element.replaceWith(tplEl);
    $compile(tplEl)(scope);
  });
}
    };
  }])

  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
// Regex: capture the whole query string and replace it with the string that will be used to match
// the results, for example if the capture is &quot;a&quot; the result will be \a
return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
return /&lt;.*&gt;/g.test(matchItem);
    }

    return function(matchItem, query) {
if (!isSanitizePresent &amp;&amp; containsHtml(matchItem)) {
  $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
}
matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '&lt;strong&gt;$&amp;&lt;/strong&gt;') : matchItem; // Replaces the capture string with a the same string inside of a &quot;strong&quot; tag
if (!isSanitizePresent) {
  matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
}
return matchItem;
    };
  }]);

angular.module(&quot;uib/template/accordion/accordion-group.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/accordion/accordion-group.html&quot;,
    &quot;&lt;div role=\&quot;tab\&quot; id=\&quot;{{::headingId}}\&quot; aria-selected=\&quot;{{isOpen}}\&quot; class=\&quot;panel-heading\&quot; ng-keypress=\&quot;toggleOpen($event)\&quot;&gt;\n&quot; +
    &quot;  &lt;h4 class=\&quot;panel-title\&quot;&gt;\n&quot; +
    &quot;    &lt;a role=\&quot;button\&quot; data-toggle=\&quot;collapse\&quot; href aria-expanded=\&quot;{{isOpen}}\&quot; aria-controls=\&quot;{{::panelId}}\&quot; tabindex=\&quot;0\&quot; class=\&quot;accordion-toggle\&quot; ng-click=\&quot;toggleOpen()\&quot; uib-accordion-transclude=\&quot;heading\&quot; ng-disabled=\&quot;isDisabled\&quot; uib-tabindex-toggle&gt;&lt;span uib-accordion-header ng-class=\&quot;{'text-muted': isDisabled}\&quot;&gt;{{heading}}&lt;/span&gt;&lt;/a&gt;\n&quot; +
    &quot;  &lt;/h4&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&lt;div id=\&quot;{{::panelId}}\&quot; aria-labelledby=\&quot;{{::headingId}}\&quot; aria-hidden=\&quot;{{!isOpen}}\&quot; role=\&quot;tabpanel\&quot; class=\&quot;panel-collapse collapse\&quot; uib-collapse=\&quot;!isOpen\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;panel-body\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/accordion/accordion.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/accordion/accordion.html&quot;,
    &quot;&lt;div role=\&quot;tablist\&quot; class=\&quot;panel-group\&quot; ng-transclude&gt;&lt;/div&gt;&quot;);
}]);

angular.module(&quot;uib/template/alert/alert.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/alert/alert.html&quot;,
    &quot;&lt;button ng-show=\&quot;closeable\&quot; type=\&quot;button\&quot; class=\&quot;close\&quot; ng-click=\&quot;close({$event: $event})\&quot;&gt;\n&quot; +
    &quot;  &lt;span aria-hidden=\&quot;true\&quot;&gt;&amp;times;&lt;/span&gt;\n&quot; +
    &quot;  &lt;span class=\&quot;sr-only\&quot;&gt;Close&lt;/span&gt;\n&quot; +
    &quot;&lt;/button&gt;\n&quot; +
    &quot;&lt;div ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/carousel/carousel.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/carousel/carousel.html&quot;,
    &quot;&lt;div class=\&quot;carousel-inner\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;a role=\&quot;button\&quot; href class=\&quot;left carousel-control\&quot; ng-click=\&quot;prev()\&quot; ng-class=\&quot;{ disabled: isPrevDisabled() }\&quot; ng-show=\&quot;slides.length &gt; 1\&quot;&gt;\n&quot; +
    &quot;  &lt;span aria-hidden=\&quot;true\&quot; class=\&quot;glyphicon glyphicon-chevron-left\&quot;&gt;&lt;/span&gt;\n&quot; +
    &quot;  &lt;span class=\&quot;sr-only\&quot;&gt;previous&lt;/span&gt;\n&quot; +
    &quot;&lt;/a&gt;\n&quot; +
    &quot;&lt;a role=\&quot;button\&quot; href class=\&quot;right carousel-control\&quot; ng-click=\&quot;next()\&quot; ng-class=\&quot;{ disabled: isNextDisabled() }\&quot; ng-show=\&quot;slides.length &gt; 1\&quot;&gt;\n&quot; +
    &quot;  &lt;span aria-hidden=\&quot;true\&quot; class=\&quot;glyphicon glyphicon-chevron-right\&quot;&gt;&lt;/span&gt;\n&quot; +
    &quot;  &lt;span class=\&quot;sr-only\&quot;&gt;next&lt;/span&gt;\n&quot; +
    &quot;&lt;/a&gt;\n&quot; +
    &quot;&lt;ol class=\&quot;carousel-indicators\&quot; ng-show=\&quot;slides.length &gt; 1\&quot;&gt;\n&quot; +
    &quot;  &lt;li ng-repeat=\&quot;slide in slides | orderBy:indexOfSlide track by $index\&quot; ng-class=\&quot;{ active: isActive(slide) }\&quot; ng-click=\&quot;select(slide)\&quot;&gt;\n&quot; +
    &quot;    &lt;span class=\&quot;sr-only\&quot;&gt;slide {{ $index + 1 }} of {{ slides.length }}&lt;span ng-if=\&quot;isActive(slide)\&quot;&gt;, currently active&lt;/span&gt;&lt;/span&gt;\n&quot; +
    &quot;  &lt;/li&gt;\n&quot; +
    &quot;&lt;/ol&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/carousel/slide.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/carousel/slide.html&quot;,
    &quot;&lt;div class=\&quot;text-center\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/datepicker/datepicker.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/datepicker/datepicker.html&quot;,
    &quot;&lt;div ng-switch=\&quot;datepickerMode\&quot;&gt;\n&quot; +
    &quot;  &lt;div uib-daypicker ng-switch-when=\&quot;day\&quot; tabindex=\&quot;0\&quot; class=\&quot;uib-daypicker\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;div uib-monthpicker ng-switch-when=\&quot;month\&quot; tabindex=\&quot;0\&quot; class=\&quot;uib-monthpicker\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;div uib-yearpicker ng-switch-when=\&quot;year\&quot; tabindex=\&quot;0\&quot; class=\&quot;uib-yearpicker\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/datepicker/day.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/datepicker/day.html&quot;,
    &quot;&lt;table role=\&quot;grid\&quot; aria-labelledby=\&quot;{{::uniqueId}}-title\&quot; aria-activedescendant=\&quot;{{activeDateId}}\&quot;&gt;\n&quot; +
    &quot;  &lt;thead&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-left uib-left\&quot; ng-click=\&quot;move(-1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-left\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th colspan=\&quot;{{::5 + showWeeks}}\&quot;&gt;&lt;button id=\&quot;{{::uniqueId}}-title\&quot; role=\&quot;heading\&quot; aria-live=\&quot;assertive\&quot; aria-atomic=\&quot;true\&quot; type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm uib-title\&quot; ng-click=\&quot;toggleMode()\&quot; ng-disabled=\&quot;datepickerMode === maxMode\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-right uib-right\&quot; ng-click=\&quot;move(1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-right\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;th ng-if=\&quot;showWeeks\&quot; class=\&quot;text-center\&quot;&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th ng-repeat=\&quot;label in ::labels track by $index\&quot; class=\&quot;text-center\&quot;&gt;&lt;small aria-label=\&quot;{{::label.full}}\&quot;&gt;{{::label.abbr}}&lt;/small&gt;&lt;/th&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/thead&gt;\n&quot; +
    &quot;  &lt;tbody&gt;\n&quot; +
    &quot;    &lt;tr class=\&quot;uib-weeks\&quot; ng-repeat=\&quot;row in rows track by $index\&quot; role=\&quot;row\&quot;&gt;\n&quot; +
    &quot;      &lt;td ng-if=\&quot;showWeeks\&quot; class=\&quot;text-center h6\&quot;&gt;&lt;em&gt;{{ weekNumbers[$index] }}&lt;/em&gt;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-repeat=\&quot;dt in row\&quot; class=\&quot;uib-day text-center\&quot; role=\&quot;gridcell\&quot;\n&quot; +
    &quot;        id=\&quot;{{::dt.uid}}\&quot;\n&quot; +
    &quot;        ng-class=\&quot;::dt.customClass\&quot;&gt;\n&quot; +
    &quot;        &lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm\&quot;\n&quot; +
    &quot;          uib-is-class=\&quot;\n&quot; +
    &quot;            'btn-info' for selectedDt,\n&quot; +
    &quot;            'active' for activeDt\n&quot; +
    &quot;            on dt\&quot;\n&quot; +
    &quot;          ng-click=\&quot;select(dt.date)\&quot;\n&quot; +
    &quot;          ng-disabled=\&quot;::dt.disabled\&quot;\n&quot; +
    &quot;          tabindex=\&quot;-1\&quot;&gt;&lt;span ng-class=\&quot;::{'text-muted': dt.secondary, 'text-info': dt.current}\&quot;&gt;{{::dt.label}}&lt;/span&gt;&lt;/button&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/tbody&gt;\n&quot; +
    &quot;&lt;/table&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/datepicker/month.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/datepicker/month.html&quot;,
    &quot;&lt;table role=\&quot;grid\&quot; aria-labelledby=\&quot;{{::uniqueId}}-title\&quot; aria-activedescendant=\&quot;{{activeDateId}}\&quot;&gt;\n&quot; +
    &quot;  &lt;thead&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-left uib-left\&quot; ng-click=\&quot;move(-1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-left\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th colspan=\&quot;{{::yearHeaderColspan}}\&quot;&gt;&lt;button id=\&quot;{{::uniqueId}}-title\&quot; role=\&quot;heading\&quot; aria-live=\&quot;assertive\&quot; aria-atomic=\&quot;true\&quot; type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm uib-title\&quot; ng-click=\&quot;toggleMode()\&quot; ng-disabled=\&quot;datepickerMode === maxMode\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-right uib-right\&quot; ng-click=\&quot;move(1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-right\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/thead&gt;\n&quot; +
    &quot;  &lt;tbody&gt;\n&quot; +
    &quot;    &lt;tr class=\&quot;uib-months\&quot; ng-repeat=\&quot;row in rows track by $index\&quot; role=\&quot;row\&quot;&gt;\n&quot; +
    &quot;      &lt;td ng-repeat=\&quot;dt in row\&quot; class=\&quot;uib-month text-center\&quot; role=\&quot;gridcell\&quot;\n&quot; +
    &quot;        id=\&quot;{{::dt.uid}}\&quot;\n&quot; +
    &quot;        ng-class=\&quot;::dt.customClass\&quot;&gt;\n&quot; +
    &quot;        &lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default\&quot;\n&quot; +
    &quot;          uib-is-class=\&quot;\n&quot; +
    &quot;            'btn-info' for selectedDt,\n&quot; +
    &quot;            'active' for activeDt\n&quot; +
    &quot;            on dt\&quot;\n&quot; +
    &quot;          ng-click=\&quot;select(dt.date)\&quot;\n&quot; +
    &quot;          ng-disabled=\&quot;::dt.disabled\&quot;\n&quot; +
    &quot;          tabindex=\&quot;-1\&quot;&gt;&lt;span ng-class=\&quot;::{'text-info': dt.current}\&quot;&gt;{{::dt.label}}&lt;/span&gt;&lt;/button&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/tbody&gt;\n&quot; +
    &quot;&lt;/table&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/datepicker/year.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/datepicker/year.html&quot;,
    &quot;&lt;table role=\&quot;grid\&quot; aria-labelledby=\&quot;{{::uniqueId}}-title\&quot; aria-activedescendant=\&quot;{{activeDateId}}\&quot;&gt;\n&quot; +
    &quot;  &lt;thead&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-left uib-left\&quot; ng-click=\&quot;move(-1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-left\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th colspan=\&quot;{{::columns - 2}}\&quot;&gt;&lt;button id=\&quot;{{::uniqueId}}-title\&quot; role=\&quot;heading\&quot; aria-live=\&quot;assertive\&quot; aria-atomic=\&quot;true\&quot; type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm uib-title\&quot; ng-click=\&quot;toggleMode()\&quot; ng-disabled=\&quot;datepickerMode === maxMode\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-right uib-right\&quot; ng-click=\&quot;move(1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-right\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/thead&gt;\n&quot; +
    &quot;  &lt;tbody&gt;\n&quot; +
    &quot;    &lt;tr class=\&quot;uib-years\&quot; ng-repeat=\&quot;row in rows track by $index\&quot; role=\&quot;row\&quot;&gt;\n&quot; +
    &quot;      &lt;td ng-repeat=\&quot;dt in row\&quot; class=\&quot;uib-year text-center\&quot; role=\&quot;gridcell\&quot;\n&quot; +
    &quot;        id=\&quot;{{::dt.uid}}\&quot;\n&quot; +
    &quot;        ng-class=\&quot;::dt.customClass\&quot;&gt;\n&quot; +
    &quot;        &lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default\&quot;\n&quot; +
    &quot;          uib-is-class=\&quot;\n&quot; +
    &quot;            'btn-info' for selectedDt,\n&quot; +
    &quot;            'active' for activeDt\n&quot; +
    &quot;            on dt\&quot;\n&quot; +
    &quot;          ng-click=\&quot;select(dt.date)\&quot;\n&quot; +
    &quot;          ng-disabled=\&quot;::dt.disabled\&quot;\n&quot; +
    &quot;          tabindex=\&quot;-1\&quot;&gt;&lt;span ng-class=\&quot;::{'text-info': dt.current}\&quot;&gt;{{::dt.label}}&lt;/span&gt;&lt;/button&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/tbody&gt;\n&quot; +
    &quot;&lt;/table&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/datepickerPopup/popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/datepickerPopup/popup.html&quot;,
    &quot;&lt;ul class=\&quot;uib-datepicker-popup dropdown-menu uib-position-measure\&quot; dropdown-nested ng-if=\&quot;isOpen\&quot; ng-keydown=\&quot;keydown($event)\&quot; ng-click=\&quot;$event.stopPropagation()\&quot;&gt;\n&quot; +
    &quot;  &lt;li ng-transclude&gt;&lt;/li&gt;\n&quot; +
    &quot;  &lt;li ng-if=\&quot;showButtonBar\&quot; class=\&quot;uib-button-bar\&quot;&gt;\n&quot; +
    &quot;    &lt;span class=\&quot;btn-group pull-left\&quot;&gt;\n&quot; +
    &quot;      &lt;button type=\&quot;button\&quot; class=\&quot;btn btn-sm btn-info uib-datepicker-current\&quot; ng-click=\&quot;select('today', $event)\&quot; ng-disabled=\&quot;isDisabled('today')\&quot;&gt;{{ getText('current') }}&lt;/button&gt;\n&quot; +
    &quot;      &lt;button type=\&quot;button\&quot; class=\&quot;btn btn-sm btn-danger uib-clear\&quot; ng-click=\&quot;select(null, $event)\&quot;&gt;{{ getText('clear') }}&lt;/button&gt;\n&quot; +
    &quot;    &lt;/span&gt;\n&quot; +
    &quot;    &lt;button type=\&quot;button\&quot; class=\&quot;btn btn-sm btn-success pull-right uib-close\&quot; ng-click=\&quot;close($event)\&quot;&gt;{{ getText('close') }}&lt;/button&gt;\n&quot; +
    &quot;  &lt;/li&gt;\n&quot; +
    &quot;&lt;/ul&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/modal/window.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/modal/window.html&quot;,
    &quot;&lt;div class=\&quot;modal-dialog {{size ? 'modal-' + size : ''}}\&quot;&gt;&lt;div class=\&quot;modal-content\&quot; uib-modal-transclude&gt;&lt;/div&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/pager/pager.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/pager/pager.html&quot;,
    &quot;&lt;li ng-class=\&quot;{disabled: noPrevious()||ngDisabled, previous: align}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page - 1, $event)\&quot; ng-disabled=\&quot;noPrevious()||ngDisabled\&quot; uib-tabindex-toggle&gt;{{::getText('previous')}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&lt;li ng-class=\&quot;{disabled: noNext()||ngDisabled, next: align}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page + 1, $event)\&quot; ng-disabled=\&quot;noNext()||ngDisabled\&quot; uib-tabindex-toggle&gt;{{::getText('next')}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/pagination/pagination.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/pagination/pagination.html&quot;,
    &quot;&lt;li ng-if=\&quot;::boundaryLinks\&quot; ng-class=\&quot;{disabled: noPrevious()||ngDisabled}\&quot; class=\&quot;pagination-first\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(1, $event)\&quot; ng-disabled=\&quot;noPrevious()||ngDisabled\&quot; uib-tabindex-toggle&gt;{{::getText('first')}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&lt;li ng-if=\&quot;::directionLinks\&quot; ng-class=\&quot;{disabled: noPrevious()||ngDisabled}\&quot; class=\&quot;pagination-prev\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page - 1, $event)\&quot; ng-disabled=\&quot;noPrevious()||ngDisabled\&quot; uib-tabindex-toggle&gt;{{::getText('previous')}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&lt;li ng-repeat=\&quot;page in pages track by $index\&quot; ng-class=\&quot;{active: page.active,disabled: ngDisabled&amp;&amp;!page.active}\&quot; class=\&quot;pagination-page\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page.number, $event)\&quot; ng-disabled=\&quot;ngDisabled&amp;&amp;!page.active\&quot; uib-tabindex-toggle&gt;{{page.text}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&lt;li ng-if=\&quot;::directionLinks\&quot; ng-class=\&quot;{disabled: noNext()||ngDisabled}\&quot; class=\&quot;pagination-next\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page + 1, $event)\&quot; ng-disabled=\&quot;noNext()||ngDisabled\&quot; uib-tabindex-toggle&gt;{{::getText('next')}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&lt;li ng-if=\&quot;::boundaryLinks\&quot; ng-class=\&quot;{disabled: noNext()||ngDisabled}\&quot; class=\&quot;pagination-last\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(totalPages, $event)\&quot; ng-disabled=\&quot;noNext()||ngDisabled\&quot; uib-tabindex-toggle&gt;{{::getText('last')}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/tooltip/tooltip-html-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/tooltip/tooltip-html-popup.html&quot;,
    &quot;&lt;div class=\&quot;tooltip-arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;div class=\&quot;tooltip-inner\&quot; ng-bind-html=\&quot;contentExp()\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/tooltip/tooltip-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/tooltip/tooltip-popup.html&quot;,
    &quot;&lt;div class=\&quot;tooltip-arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;div class=\&quot;tooltip-inner\&quot; ng-bind=\&quot;content\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/tooltip/tooltip-template-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/tooltip/tooltip-template-popup.html&quot;,
    &quot;&lt;div class=\&quot;tooltip-arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;div class=\&quot;tooltip-inner\&quot;\n&quot; +
    &quot;  uib-tooltip-template-transclude=\&quot;contentExp()\&quot;\n&quot; +
    &quot;  tooltip-template-transclude-scope=\&quot;originScope()\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/popover/popover-html.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/popover/popover-html.html&quot;,
    &quot;&lt;div class=\&quot;arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;\n&quot; +
    &quot;&lt;div class=\&quot;popover-inner\&quot;&gt;\n&quot; +
    &quot;    &lt;h3 class=\&quot;popover-title\&quot; ng-bind=\&quot;uibTitle\&quot; ng-if=\&quot;uibTitle\&quot;&gt;&lt;/h3&gt;\n&quot; +
    &quot;    &lt;div class=\&quot;popover-content\&quot; ng-bind-html=\&quot;contentExp()\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/popover/popover-template.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/popover/popover-template.html&quot;,
    &quot;&lt;div class=\&quot;arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;\n&quot; +
    &quot;&lt;div class=\&quot;popover-inner\&quot;&gt;\n&quot; +
    &quot;    &lt;h3 class=\&quot;popover-title\&quot; ng-bind=\&quot;uibTitle\&quot; ng-if=\&quot;uibTitle\&quot;&gt;&lt;/h3&gt;\n&quot; +
    &quot;    &lt;div class=\&quot;popover-content\&quot;\n&quot; +
    &quot;      uib-tooltip-template-transclude=\&quot;contentExp()\&quot;\n&quot; +
    &quot;      tooltip-template-transclude-scope=\&quot;originScope()\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/popover/popover.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/popover/popover.html&quot;,
    &quot;&lt;div class=\&quot;arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;\n&quot; +
    &quot;&lt;div class=\&quot;popover-inner\&quot;&gt;\n&quot; +
    &quot;    &lt;h3 class=\&quot;popover-title\&quot; ng-bind=\&quot;uibTitle\&quot; ng-if=\&quot;uibTitle\&quot;&gt;&lt;/h3&gt;\n&quot; +
    &quot;    &lt;div class=\&quot;popover-content\&quot; ng-bind=\&quot;content\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/progressbar/bar.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/progressbar/bar.html&quot;,
    &quot;&lt;div class=\&quot;progress-bar\&quot; ng-class=\&quot;type &amp;&amp; 'progress-bar-' + type\&quot; role=\&quot;progressbar\&quot; aria-valuenow=\&quot;{{value}}\&quot; aria-valuemin=\&quot;0\&quot; aria-valuemax=\&quot;{{max}}\&quot; ng-style=\&quot;{width: (percent &lt; 100 ? percent : 100) + '%'}\&quot; aria-valuetext=\&quot;{{percent | number:0}}%\&quot; aria-labelledby=\&quot;{{::title}}\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/progressbar/progress.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/progressbar/progress.html&quot;,
    &quot;&lt;div class=\&quot;progress\&quot; ng-transclude aria-labelledby=\&quot;{{::title}}\&quot;&gt;&lt;/div&gt;&quot;);
}]);

angular.module(&quot;uib/template/progressbar/progressbar.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/progressbar/progressbar.html&quot;,
    &quot;&lt;div class=\&quot;progress\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;progress-bar\&quot; ng-class=\&quot;type &amp;&amp; 'progress-bar-' + type\&quot; role=\&quot;progressbar\&quot; aria-valuenow=\&quot;{{value}}\&quot; aria-valuemin=\&quot;0\&quot; aria-valuemax=\&quot;{{max}}\&quot; ng-style=\&quot;{width: (percent &lt; 100 ? percent : 100) + '%'}\&quot; aria-valuetext=\&quot;{{percent | number:0}}%\&quot; aria-labelledby=\&quot;{{::title}}\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/rating/rating.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/rating/rating.html&quot;,
    &quot;&lt;span ng-mouseleave=\&quot;reset()\&quot; ng-keydown=\&quot;onKeydown($event)\&quot; tabindex=\&quot;0\&quot; role=\&quot;slider\&quot; aria-valuemin=\&quot;0\&quot; aria-valuemax=\&quot;{{range.length}}\&quot; aria-valuenow=\&quot;{{value}}\&quot; aria-valuetext=\&quot;{{title}}\&quot;&gt;\n&quot; +
    &quot;    &lt;span ng-repeat-start=\&quot;r in range track by $index\&quot; class=\&quot;sr-only\&quot;&gt;({{ $index &lt; value ? '*' : ' ' }})&lt;/span&gt;\n&quot; +
    &quot;    &lt;i ng-repeat-end ng-mouseenter=\&quot;enter($index + 1)\&quot; ng-click=\&quot;rate($index + 1)\&quot; class=\&quot;glyphicon\&quot; ng-class=\&quot;$index &lt; value &amp;&amp; (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\&quot; ng-attr-title=\&quot;{{r.title}}\&quot;&gt;&lt;/i&gt;\n&quot; +
    &quot;&lt;/span&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/tabs/tab.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/tabs/tab.html&quot;,
    &quot;&lt;li ng-class=\&quot;[{active: active, disabled: disabled}, classes]\&quot; class=\&quot;uib-tab nav-item\&quot;&gt;\n&quot; +
    &quot;  &lt;a href ng-click=\&quot;select($event)\&quot; class=\&quot;nav-link\&quot; uib-tab-heading-transclude&gt;{{heading}}&lt;/a&gt;\n&quot; +
    &quot;&lt;/li&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/tabs/tabset.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/tabs/tabset.html&quot;,
    &quot;&lt;div&gt;\n&quot; +
    &quot;  &lt;ul class=\&quot;nav nav-{{tabset.type || 'tabs'}}\&quot; ng-class=\&quot;{'nav-stacked': vertical, 'nav-justified': justified}\&quot; ng-transclude&gt;&lt;/ul&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tab-content\&quot;&gt;\n&quot; +
    &quot;    &lt;div class=\&quot;tab-pane\&quot;\n&quot; +
    &quot;         ng-repeat=\&quot;tab in tabset.tabs\&quot;\n&quot; +
    &quot;         ng-class=\&quot;{active: tabset.active === tab.index}\&quot;\n&quot; +
    &quot;         uib-tab-content-transclude=\&quot;tab\&quot;&gt;\n&quot; +
    &quot;    &lt;/div&gt;\n&quot; +
    &quot;  &lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/timepicker/timepicker.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/timepicker/timepicker.html&quot;,
    &quot;&lt;table class=\&quot;uib-timepicker\&quot;&gt;\n&quot; +
    &quot;  &lt;tbody&gt;\n&quot; +
    &quot;    &lt;tr class=\&quot;text-center\&quot; ng-show=\&quot;::showSpinners\&quot;&gt;\n&quot; +
    &quot;      &lt;td class=\&quot;uib-increment hours\&quot;&gt;&lt;a ng-click=\&quot;incrementHours()\&quot; ng-class=\&quot;{disabled: noIncrementHours()}\&quot; class=\&quot;btn btn-link\&quot; ng-disabled=\&quot;noIncrementHours()\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-up\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td class=\&quot;uib-increment minutes\&quot;&gt;&lt;a ng-click=\&quot;incrementMinutes()\&quot; ng-class=\&quot;{disabled: noIncrementMinutes()}\&quot; class=\&quot;btn btn-link\&quot; ng-disabled=\&quot;noIncrementMinutes()\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-up\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showSeconds\&quot;&gt;&amp;nbsp;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showSeconds\&quot; class=\&quot;uib-increment seconds\&quot;&gt;&lt;a ng-click=\&quot;incrementSeconds()\&quot; ng-class=\&quot;{disabled: noIncrementSeconds()}\&quot; class=\&quot;btn btn-link\&quot; ng-disabled=\&quot;noIncrementSeconds()\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-up\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showMeridian\&quot;&gt;&lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;td class=\&quot;form-group uib-time hours\&quot; ng-class=\&quot;{'has-error': invalidHours}\&quot;&gt;\n&quot; +
    &quot;        &lt;input type=\&quot;text\&quot; placeholder=\&quot;HH\&quot; ng-model=\&quot;hours\&quot; ng-change=\&quot;updateHours()\&quot; class=\&quot;form-control text-center\&quot; ng-readonly=\&quot;::readonlyInput\&quot; maxlength=\&quot;2\&quot; tabindex=\&quot;{{::tabindex}}\&quot; ng-disabled=\&quot;noIncrementHours()\&quot; ng-blur=\&quot;blur()\&quot;&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;      &lt;td class=\&quot;uib-separator\&quot;&gt;:&lt;/td&gt;\n&quot; +
    &quot;      &lt;td class=\&quot;form-group uib-time minutes\&quot; ng-class=\&quot;{'has-error': invalidMinutes}\&quot;&gt;\n&quot; +
    &quot;        &lt;input type=\&quot;text\&quot; placeholder=\&quot;MM\&quot; ng-model=\&quot;minutes\&quot; ng-change=\&quot;updateMinutes()\&quot; class=\&quot;form-control text-center\&quot; ng-readonly=\&quot;::readonlyInput\&quot; maxlength=\&quot;2\&quot; tabindex=\&quot;{{::tabindex}}\&quot; ng-disabled=\&quot;noIncrementMinutes()\&quot; ng-blur=\&quot;blur()\&quot;&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showSeconds\&quot; class=\&quot;uib-separator\&quot;&gt;:&lt;/td&gt;\n&quot; +
    &quot;      &lt;td class=\&quot;form-group uib-time seconds\&quot; ng-class=\&quot;{'has-error': invalidSeconds}\&quot; ng-show=\&quot;showSeconds\&quot;&gt;\n&quot; +
    &quot;        &lt;input type=\&quot;text\&quot; placeholder=\&quot;SS\&quot; ng-model=\&quot;seconds\&quot; ng-change=\&quot;updateSeconds()\&quot; class=\&quot;form-control text-center\&quot; ng-readonly=\&quot;readonlyInput\&quot; maxlength=\&quot;2\&quot; tabindex=\&quot;{{::tabindex}}\&quot; ng-disabled=\&quot;noIncrementSeconds()\&quot; ng-blur=\&quot;blur()\&quot;&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showMeridian\&quot; class=\&quot;uib-time am-pm\&quot;&gt;&lt;button type=\&quot;button\&quot; ng-class=\&quot;{disabled: noToggleMeridian()}\&quot; class=\&quot;btn btn-default text-center\&quot; ng-click=\&quot;toggleMeridian()\&quot; ng-disabled=\&quot;noToggleMeridian()\&quot; tabindex=\&quot;{{::tabindex}}\&quot;&gt;{{meridian}}&lt;/button&gt;&lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;    &lt;tr class=\&quot;text-center\&quot; ng-show=\&quot;::showSpinners\&quot;&gt;\n&quot; +
    &quot;      &lt;td class=\&quot;uib-decrement hours\&quot;&gt;&lt;a ng-click=\&quot;decrementHours()\&quot; ng-class=\&quot;{disabled: noDecrementHours()}\&quot; class=\&quot;btn btn-link\&quot; ng-disabled=\&quot;noDecrementHours()\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-down\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td class=\&quot;uib-decrement minutes\&quot;&gt;&lt;a ng-click=\&quot;decrementMinutes()\&quot; ng-class=\&quot;{disabled: noDecrementMinutes()}\&quot; class=\&quot;btn btn-link\&quot; ng-disabled=\&quot;noDecrementMinutes()\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-down\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showSeconds\&quot;&gt;&amp;nbsp;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showSeconds\&quot; class=\&quot;uib-decrement seconds\&quot;&gt;&lt;a ng-click=\&quot;decrementSeconds()\&quot; ng-class=\&quot;{disabled: noDecrementSeconds()}\&quot; class=\&quot;btn btn-link\&quot; ng-disabled=\&quot;noDecrementSeconds()\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-down\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showMeridian\&quot;&gt;&lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/tbody&gt;\n&quot; +
    &quot;&lt;/table&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/typeahead/typeahead-match.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/typeahead/typeahead-match.html&quot;,
    &quot;&lt;a href\n&quot; +
    &quot;   tabindex=\&quot;-1\&quot;\n&quot; +
    &quot;   ng-bind-html=\&quot;match.label | uibTypeaheadHighlight:query\&quot;\n&quot; +
    &quot;   ng-attr-title=\&quot;{{match.label}}\&quot;&gt;&lt;/a&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;uib/template/typeahead/typeahead-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;uib/template/typeahead/typeahead-popup.html&quot;,
    &quot;&lt;ul class=\&quot;dropdown-menu\&quot; ng-show=\&quot;isOpen() &amp;&amp; !moveInProgress\&quot; ng-style=\&quot;{top: position().top+'px', left: position().left+'px'}\&quot; role=\&quot;listbox\&quot; aria-hidden=\&quot;{{!isOpen()}}\&quot;&gt;\n&quot; +
    &quot;    &lt;li class=\&quot;uib-typeahead-match\&quot; ng-repeat=\&quot;match in matches track by $index\&quot; ng-class=\&quot;{active: isActive($index) }\&quot; ng-mouseenter=\&quot;selectActive($index)\&quot; ng-click=\&quot;selectMatch($index, $event)\&quot; role=\&quot;option\&quot; id=\&quot;{{::match.id}}\&quot;&gt;\n&quot; +
    &quot;        &lt;div uib-typeahead-match index=\&quot;$index\&quot; match=\&quot;match\&quot; query=\&quot;query\&quot; template-url=\&quot;templateUrl\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;    &lt;/li&gt;\n&quot; +
    &quot;&lt;/ul&gt;\n&quot; +
    &quot;&quot;);
}]);
angular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle &amp;&amp; !angular.$$uibCarouselCss &amp;&amp; angular.element(document).find('head').prepend('&lt;style type=&quot;text/css&quot;&gt;.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}&lt;/style&gt;'); angular.$$uibCarouselCss = true; });
angular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle &amp;&amp; !angular.$$uibDatepickerCss &amp;&amp; angular.element(document).find('head').prepend('&lt;style type=&quot;text/css&quot;&gt;.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}&lt;/style&gt;'); angular.$$uibDatepickerCss = true; });
angular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle &amp;&amp; !angular.$$uibPositionCss &amp;&amp; angular.element(document).find('head').prepend('&lt;style type=&quot;text/css&quot;&gt;.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}&lt;/style&gt;'); angular.$$uibPositionCss = true; });
angular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle &amp;&amp; !angular.$$uibDatepickerpopupCss &amp;&amp; angular.element(document).find('head').prepend('&lt;style type=&quot;text/css&quot;&gt;.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}&lt;/style&gt;'); angular.$$uibDatepickerpopupCss = true; });
angular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle &amp;&amp; !angular.$$uibTooltipCss &amp;&amp; angular.element(document).find('head').prepend('&lt;style type=&quot;text/css&quot;&gt;[uib-tooltip-popup].tooltip.top-left &gt; .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right &gt; .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left &gt; .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right &gt; .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top &gt; .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom &gt; .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top &gt; .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom &gt; .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left &gt; .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right &gt; .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left &gt; .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right &gt; .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top &gt; .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom &gt; .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top &gt; .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom &gt; .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left &gt; .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right &gt; .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left &gt; .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right &gt; .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top &gt; .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom &gt; .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top &gt; .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom &gt; .tooltip-arrow,[uib-popover-popup].popover.top-left &gt; .arrow,[uib-popover-popup].popover.top-right &gt; .arrow,[uib-popover-popup].popover.bottom-left &gt; .arrow,[uib-popover-popup].popover.bottom-right &gt; .arrow,[uib-popover-popup].popover.left-top &gt; .arrow,[uib-popover-popup].popover.left-bottom &gt; .arrow,[uib-popover-popup].popover.right-top &gt; .arrow,[uib-popover-popup].popover.right-bottom &gt; .arrow,[uib-popover-html-popup].popover.top-left &gt; .arrow,[uib-popover-html-popup].popover.top-right &gt; .arrow,[uib-popover-html-popup].popover.bottom-left &gt; .arrow,[uib-popover-html-popup].popover.bottom-right &gt; .arrow,[uib-popover-html-popup].popover.left-top &gt; .arrow,[uib-popover-html-popup].popover.left-bottom &gt; .arrow,[uib-popover-html-popup].popover.right-top &gt; .arrow,[uib-popover-html-popup].popover.right-bottom &gt; .arrow,[uib-popover-template-popup].popover.top-left &gt; .arrow,[uib-popover-template-popup].popover.top-right &gt; .arrow,[uib-popover-template-popup].popover.bottom-left &gt; .arrow,[uib-popover-template-popup].popover.bottom-right &gt; .arrow,[uib-popover-template-popup].popover.left-top &gt; .arrow,[uib-popover-template-popup].popover.left-bottom &gt; .arrow,[uib-popover-template-popup].popover.right-top &gt; .arrow,[uib-popover-template-popup].popover.right-bottom &gt; .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}&lt;/style&gt;'); angular.$$uibTooltipCss = true; });
angular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle &amp;&amp; !angular.$$uibTimepickerCss &amp;&amp; angular.element(document).find('head').prepend('&lt;style type=&quot;text/css&quot;&gt;.uib-time input{width:50px;}&lt;/style&gt;'); angular.$$uibTimepickerCss = true; });
angular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle &amp;&amp; !angular.$$uibTypeaheadCss &amp;&amp; angular.element(document).find('head').prepend('&lt;style type=&quot;text/css&quot;&gt;[uib-typeahead-popup].dropdown-menu{display:block;}&lt;/style&gt;'); angular.$$uibTypeaheadCss = true; });</code></pre>
        </div>
      </div>
    </div>
    <footer class="footer">
      <div class="container">
        <p>Documentation generated with <a href="https://github.com/mr-doc/mr-doc">Mr. Doc </a> created by <a href="https://twitter.com/FGRibreau" data-show-count="false" class="twitter-follow-button">Francois-Guillaume Ribreau </a></p>
        <p>Mr. Doc is sponsored by <a href="http://bringr.net/?btt" title="Outil d'analyse des rseaux sociaux" class="bringr">Bringr </a> and <a href="https://redsmin.com/?btt" title="Full Redis GUI" class="redsmin">Redsmin</a></p>
        <p>Theme borrowed from Twitter Bootstrap</p>
      </div>
    </footer>
    <script src="../js/twitter-widget.min.js"></script>
    <script src="../js/jquery.min.js"></script>
    <script src="../js/bootstrap-transition.min.js"></script>
    <script src="../js/bootstrap-scrollspy.min.js"></script>
    <script src="../js/bootstrap-dropdown.min.js"></script>
    <script src="../js/bootstrap-collapse.min.js"></script>
    <script src="../js/bootstrap-affix.min.js"></script>
    <script src="../js/prism.min.js"></script>
    <script src="../js/index.min.js"></script>
  </body>
</html>