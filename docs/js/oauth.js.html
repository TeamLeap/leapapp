<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width" charset="utf-8">
    <title>My Project</title>
    <link rel="stylesheet" href="../css/bootstrap.min.css">
    <link rel="stylesheet" href="../css/cayman.min.css">
    <link rel="stylesheet" href="../css/prism.min.css">
    <link rel="stylesheet" href="../css/index.min.css">
    <link rel="stylesheet" href="../css/docs.min.css">
    <link rel="stylesheet" href="../css/bootstrap-responsive.min.css">
  </head>
  <body data-spy="scroll" data-target=".scrollspy">
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container"><a class="brand">Mr. Doc</a>
          <div class="nav-collapse collapse">
            <ul class="nav pull-right sponsored"></ul>
          </div>
        </div>
      </div>
    </div>
    <header id="overview" class="jumbotron subhead">
      <div class="container">
        <h1>My Project</h1>
        <p class="lead"></p>
      </div>
    </header>
    <div class="container">
      <div class="row">
        <div class="span3 bs-docs-sidebar">
          <ul class="nav nav-list bs-docs-sidenav affix-top">
            <li><a href="../index.html">Main</a></li>
            <li><a href="../bower_components/Chart.js.html">bower_components/Chart.js</a></li>
            <li><a href="../bower_components/Chart.js/dist/Chart.bundle.js.html">bower_components/Chart.js/dist/Chart.bundle.js</a></li>
            <li><a href="../bower_components/Chart.js/dist/Chart.bundle.min.js.html">bower_components/Chart.js/dist/Chart.bundle.min.js</a></li>
            <li><a href="../bower_components/Chart.js/dist/Chart.js.html">bower_components/Chart.js/dist/Chart.js</a></li>
            <li><a href="../bower_components/Chart.js/dist/Chart.min.js.html">bower_components/Chart.js/dist/Chart.min.js</a></li>
            <li><a href="../bower_components/Chart.js/gulpfile.js.html">bower_components/Chart.js/gulpfile.js</a></li>
            <li><a href="../bower_components/Chart.js/karma.conf.ci.js.html">bower_components/Chart.js/karma.conf.ci.js</a></li>
            <li><a href="../bower_components/Chart.js/karma.conf.js.html">bower_components/Chart.js/karma.conf.js</a></li>
            <li><a href="../bower_components/Chart.js/karma.coverage.conf.js.html">bower_components/Chart.js/karma.coverage.conf.js</a></li>
            <li><a href="../bower_components/Chart.js/src/chart.js.html">bower_components/Chart.js/src/chart.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Bar.js.html">bower_components/Chart.js/src/charts/Chart.Bar.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Bubble.js.html">bower_components/Chart.js/src/charts/Chart.Bubble.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Doughnut.js.html">bower_components/Chart.js/src/charts/Chart.Doughnut.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Line.js.html">bower_components/Chart.js/src/charts/Chart.Line.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.PolarArea.js.html">bower_components/Chart.js/src/charts/Chart.PolarArea.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Radar.js.html">bower_components/Chart.js/src/charts/Chart.Radar.js</a></li>
            <li><a href="../bower_components/Chart.js/src/charts/Chart.Scatter.js.html">bower_components/Chart.js/src/charts/Chart.Scatter.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.bar.js.html">bower_components/Chart.js/src/controllers/controller.bar.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.bubble.js.html">bower_components/Chart.js/src/controllers/controller.bubble.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.doughnut.js.html">bower_components/Chart.js/src/controllers/controller.doughnut.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.line.js.html">bower_components/Chart.js/src/controllers/controller.line.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.polarArea.js.html">bower_components/Chart.js/src/controllers/controller.polarArea.js</a></li>
            <li><a href="../bower_components/Chart.js/src/controllers/controller.radar.js.html">bower_components/Chart.js/src/controllers/controller.radar.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.animation.js.html">bower_components/Chart.js/src/core/core.animation.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.controller.js.html">bower_components/Chart.js/src/core/core.controller.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.datasetController.js.html">bower_components/Chart.js/src/core/core.datasetController.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.element.js.html">bower_components/Chart.js/src/core/core.element.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.helpers.js.html">bower_components/Chart.js/src/core/core.helpers.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.js.html">bower_components/Chart.js/src/core/core.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.layoutService.js.html">bower_components/Chart.js/src/core/core.layoutService.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.legend.js.html">bower_components/Chart.js/src/core/core.legend.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.plugin.js.html">bower_components/Chart.js/src/core/core.plugin.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.scale.js.html">bower_components/Chart.js/src/core/core.scale.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.scaleService.js.html">bower_components/Chart.js/src/core/core.scaleService.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.title.js.html">bower_components/Chart.js/src/core/core.title.js</a></li>
            <li><a href="../bower_components/Chart.js/src/core/core.tooltip.js.html">bower_components/Chart.js/src/core/core.tooltip.js</a></li>
            <li><a href="../bower_components/Chart.js/src/elements/element.arc.js.html">bower_components/Chart.js/src/elements/element.arc.js</a></li>
            <li><a href="../bower_components/Chart.js/src/elements/element.line.js.html">bower_components/Chart.js/src/elements/element.line.js</a></li>
            <li><a href="../bower_components/Chart.js/src/elements/element.point.js.html">bower_components/Chart.js/src/elements/element.point.js</a></li>
            <li><a href="../bower_components/Chart.js/src/elements/element.rectangle.js.html">bower_components/Chart.js/src/elements/element.rectangle.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.category.js.html">bower_components/Chart.js/src/scales/scale.category.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.linear.js.html">bower_components/Chart.js/src/scales/scale.linear.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.logarithmic.js.html">bower_components/Chart.js/src/scales/scale.logarithmic.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.radialLinear.js.html">bower_components/Chart.js/src/scales/scale.radialLinear.js</a></li>
            <li><a href="../bower_components/Chart.js/src/scales/scale.time.js.html">bower_components/Chart.js/src/scales/scale.time.js</a></li>
            <li><a href="../bower_components/angular/angular.js.html">bower_components/angular/angular.js</a></li>
            <li><a href="../bower_components/angular/angular.min.js.html">bower_components/angular/angular.min.js</a></li>
            <li><a href="../bower_components/angular/index.js.html">bower_components/angular/index.js</a></li>
            <li><a href="../bower_components/angular-charts/dist/angular-charts.js.html">bower_components/angular-charts/dist/angular-charts.js</a></li>
            <li><a href="../bower_components/angular-charts/dist/angular-charts.min.js.html">bower_components/angular-charts/dist/angular-charts.min.js</a></li>
            <li><a href="../bower_components/angular-nvd3/Gruntfile.js.html">bower_components/angular-nvd3/Gruntfile.js</a></li>
            <li><a href="../bower_components/angular-nvd3/dist/angular-nvd3.js.html">bower_components/angular-nvd3/dist/angular-nvd3.js</a></li>
            <li><a href="../bower_components/angular-nvd3/dist/angular-nvd3.min.js.html">bower_components/angular-nvd3/dist/angular-nvd3.min.js</a></li>
            <li><a href="../bower_components/angular-nvd3/index.js.html">bower_components/angular-nvd3/index.js</a></li>
            <li><a href="../bower_components/d3/d3.js.html">bower_components/d3/d3.js</a></li>
            <li><a href="../bower_components/d3/d3.min.js.html">bower_components/d3/d3.min.js</a></li>
            <li><a href="../bower_components/nvd3/build/nv.d3.js.html">bower_components/nvd3/build/nv.d3.js</a></li>
            <li><a href="../bower_components/nvd3/build/nv.d3.min.js.html">bower_components/nvd3/build/nv.d3.min.js</a></li>
            <li><a href="../bower_components/nvd3/meteor/export.js.html">bower_components/nvd3/meteor/export.js</a></li>
            <li><a href="../bower_components/nvd3/package.js.html">bower_components/nvd3/package.js</a></li>
            <li><a href="../cemetery/cemetery.controller.js.html">cemetery/cemetery.controller.js</a></li>
            <li><a href="../counsellor/counsellor.controller.js.html">counsellor/counsellor.controller.js</a></li>
            <li><a href="../docs/js/bootstrap-affix.min.js.html">docs/js/bootstrap-affix.min.js</a></li>
            <li><a href="../docs/js/bootstrap-collapse.min.js.html">docs/js/bootstrap-collapse.min.js</a></li>
            <li><a href="../docs/js/bootstrap-dropdown.min.js.html">docs/js/bootstrap-dropdown.min.js</a></li>
            <li><a href="../docs/js/bootstrap-scrollspy.min.js.html">docs/js/bootstrap-scrollspy.min.js</a></li>
            <li><a href="../docs/js/bootstrap-transition.min.js.html">docs/js/bootstrap-transition.min.js</a></li>
            <li><a href="../docs/js/index.min.js.html">docs/js/index.min.js</a></li>
            <li><a href="../docs/js/jquery.min.js.html">docs/js/jquery.min.js</a></li>
            <li><a href="../docs/js/prism.min.js.html">docs/js/prism.min.js</a></li>
            <li><a href="../docs/js/twitter-widget.min.js.html">docs/js/twitter-widget.min.js</a></li>
            <li><a href="../efleet/efleet.controller.js.html">efleet/efleet.controller.js</a></li>
            <li><a href="../ehealth/ehealth.controller.js.html">ehealth/ehealth.controller.js</a></li>
            <li><a href="../gulpfile.js.html">gulpfile.js</a></li>
            <li><a href="../hr/hr.controller.js.html">hr/hr.controller.js</a></li>
            <li><a href="../indigent/indigent.controller.js.html">indigent/indigent.controller.js</a></li>
            <li><a href="../js/app.js.html">js/app.js</a></li>
            <li><a href="../js/config.js.html">js/config.js</a></li>
            <li><a href="../js/map-icons.js.html">js/map-icons.js</a></li>
            <li><a href="../js/ng-cordova.js.html">js/ng-cordova.js</a></li>
            <li class="active"><a href="../js/oauth.js.html">js/oauth.js</a></li>
            <li><a href="../js/plugins.js.html">js/plugins.js</a></li>
            <li><a href="../js/ui-bootstrap-tpls-2.1.1.js.html">js/ui-bootstrap-tpls-2.1.1.js</a></li>
            <li><a href="../lib/angular-messages.min.js.html">lib/angular-messages.min.js</a></li>
            <li><a href="../lib/angular-nvd3.js.html">lib/angular-nvd3.js</a></li>
            <li><a href="../lib/angular.soap.js.html">lib/angular.soap.js</a></li>
            <li><a href="../lib/d3.js.html">lib/d3.js</a></li>
            <li><a href="../lib/nv.d3.js.html">lib/nv.d3.js</a></li>
            <li><a href="../lib/onsen/js/angular/angular-animate.js.html">lib/onsen/js/angular/angular-animate.js</a></li>
            <li><a href="../lib/onsen/js/angular/angular-touch.js.html">lib/onsen/js/angular/angular-touch.js</a></li>
            <li><a href="../lib/onsen/js/angular/angular.js.html">lib/onsen/js/angular/angular.js</a></li>
            <li><a href="../lib/onsen/js/angular/angular.min.js.html">lib/onsen/js/angular/angular.min.js</a></li>
            <li><a href="../lib/onsen/js/jquery-3.1.0.min.js.html">lib/onsen/js/jquery-3.1.0.min.js</a></li>
            <li><a href="../lib/onsen/js/onsenui.js.html">lib/onsen/js/onsenui.js</a></li>
            <li><a href="../lib/onsen/js/onsenui.min.js.html">lib/onsen/js/onsenui.min.js</a></li>
            <li><a href="../lib/onsen/js/onsenui_all.js.html">lib/onsen/js/onsenui_all.js</a></li>
            <li><a href="../lib/onsen/js/onsenui_all.min.js.html">lib/onsen/js/onsenui_all.min.js</a></li>
            <li><a href="../lib/signature_pad.js.html">lib/signature_pad.js</a></li>
            <li><a href="../lib/soapclient.js.html">lib/soapclient.js</a></li>
            <li><a href="../lib/swiper.js.html">lib/swiper.js</a></li>
            <li><a href="../providers/services/twitter-provider.js.html">providers/services/twitter-provider.js</a></li>
            <li><a href="../suprema/suprema.controller.js.html">suprema/suprema.controller.js</a></li>
          </ul>
          <div class="scrollspy">
            <ul class="nav nav-list bs-docs-sidenav affix-top">
              <li><a href="#Callbacks"><i class="alert alert-info"></i><span>Callbacks</span></a>
              </li>
              <li><a href="#completed"><i class="alert alert-info"></i><span>completed</span></a>
              </li>
              <li><a href="#rbrace"><i class="alert alert-success"></i><span>rbrace</span></a>
              </li>
              <li><a href="#event"><i class="alert alert-success"></i><span>event</span></a>
              </li>
              <li><a href="#ajaxHandleResponses"><i class="alert alert-info"></i><span>ajaxHandleResponses</span></a>
              </li>
              <li><a href="#ajaxConvert"><i class="alert alert-info"></i><span>ajaxConvert</span></a>
              </li>
              <li><a href="#accepts"><i class="alert alert-success"></i><span>accepts</span></a>
              </li>
              <li><a href="#load"><i class="alert alert-info"></i><span>load</span></a>
              </li>
              <li><a href="#exports"><i class="alert alert-success"></i><span>exports</span></a>
              </li>
            </ul>
          </div>
        </div>
        <div class="span9">
          <section id="Callbacks">
            <h1>Callbacks</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>jQuery.Callbacks()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Create a callback list using the following parameters:</p><pre><code>options: an optional list of space-separated options that will change how
        the callback list behaves or a more traditional option object
</code></pre><p>By default a callback list will act like an event callback list and can be<br />&quot;fired&quot; multiple times.</p><p>Possible options:</p><pre><code>once:            will ensure the callback list can only be fired once (like a Deferred)

memory:            will keep track of previous values and will call any callback added
                after the list has been fired right away with the latest &quot;memorized&quot;
                values (like a Deferred)

unique:            will ensure a callback can only be added once (no duplicate in the list)

stopOnFalse:    interrupt callings when a callback returns false
</code></pre></div>
          <pre><code class="language-javascript">jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === &quot;string&quot; ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once &amp;&amp; [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory &amp;&amp; data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === &quot;function&quot; ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg &amp;&amp; arg.length &amp;&amp; type !== &quot;string&quot; ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index &lt;= firingLength ) {
									firingLength--;
								}
								if ( index &lt;= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) &gt; -1 : !!( list &amp;&amp; list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list &amp;&amp; ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],
				[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],
				[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ]
			],
			state = &quot;pending&quot;,
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function(</code></pre>
          <div class="description"><p>fnDone, fnFail, fnProgress</p></div>
          <pre><code class="language-javascript">) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn &amp;&amp; fn.apply( this, arguments );
								if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + &quot;With&quot; ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + &quot;With&quot; ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate</code></pre>
          <div class="description"><p>, ..., subordinateN</p></div>
          <pre><code class="language-javascript">) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length &gt; 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i &lt; length; i++ ) {
				if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( &quot;ready&quot; );
			jQuery( document ).off( &quot;ready&quot; );
		}
	}
});</code></pre>
          <section id="completed">
            <h1>completed</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>completed()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>The ready event handler and self cleanup method</p></div>
          <pre><code class="language-javascript">function completed() {
	document.removeEventListener( &quot;DOMContentLoaded&quot;, completed, false );
	window.removeEventListener( &quot;load&quot;, completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === &quot;complete&quot; ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( &quot;load&quot;, completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === &quot;object&quot; ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i &lt; len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};</code></pre>
          <div class="description"><p>Determines whether an object can have data</p></div>
          <pre><code class="language-javascript">return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
// Support: Android &lt; 4,
// Old WebKit does not have Object.preventExtensions/freeze method,
// return new empty object instead with no [[set]] accessor
Object.defineProperty( this.cache = {}, 0, {
	get: function() {
		return {};
	}
});

this.expando = jQuery.expando + Math.random();
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
key: function( owner ) {
	// We can accept data for non-element nodes in modern browsers,
	// but we should not, see #8335.
	// Always return the key for a frozen object.
	if ( !Data.accepts( owner ) ) {
		return 0;
	}

	var descriptor = {},
		// Check if the owner object already has a cache key
		unlock = owner[ this.expando ];

	// If not, create one
	if ( !unlock ) {
		unlock = Data.uid++;

		// Secure it in a non-enumerable, non-writable property
		try {
			descriptor[ this.expando ] = { value: unlock };
			Object.defineProperties( owner, descriptor );

		// Support: Android &lt; 4
		// Fallback to a less secure definition
		} catch ( e ) {
			descriptor[ this.expando ] = unlock;
			jQuery.extend( owner, descriptor );
		}
	}

	// Ensure the cache object
	if ( !this.cache[ unlock ] ) {
		this.cache[ unlock ] = {};
	}

	return unlock;
},
set: function( owner, data, value ) {
	var prop,
		// There may be an unlock assigned to this node,
		// if there is no entry for this &quot;owner&quot;, create one inline
		// and set the unlock as though an owner entry had always existed
		unlock = this.key( owner ),
		cache = this.cache[ unlock ];

	// Handle: [ owner, key, value ] args
	if ( typeof data === &quot;string&quot; ) {
		cache[ data ] = value;

	// Handle: [ owner, { properties } ] args
	} else {
		// Fresh assignments by object are shallow copied
		if ( jQuery.isEmptyObject( cache ) ) {
			jQuery.extend( this.cache[ unlock ], data );
		// Otherwise, copy the properties one-by-one to the cache object
		} else {
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
	}
	return cache;
},
get: function( owner, key ) {
	// Either a valid cache is found, or will be created.
	// New caches will be created and the unlock returned,
	// allowing direct access to the newly created
	// empty data object. A valid owner object must be provided.
	var cache = this.cache[ this.key( owner ) ];

	return key === undefined ?
		cache : cache[ key ];
},
access: function( owner, key, value ) {
	var stored;
	// In cases where either:
	//
	//   1. No key was specified
	//   2. A string key was specified, but no value provided
	//
	// Take the &quot;read&quot; path and allow the get method to determine
	// which value to return, respectively either:
	//
	//   1. The entire cache object
	//   2. The data stored at the key
	//
	if ( key === undefined ||
			((key &amp;&amp; typeof key === &quot;string&quot;) &amp;&amp; value === undefined) ) {

		stored = this.get( owner, key );

		return stored !== undefined ?
			stored : this.get( owner, jQuery.camelCase(key) );
	}

	// [*]When the key is not a string, or both a key and value
	// are specified, set or extend (existing objects) with either:
	//
	//   1. An object of properties
	//   2. A key and value
	//
	this.set( owner, key, value );

	// Since the &quot;set&quot; path can have two possible entry points
	// return the expected data based on which path was taken[*]
	return value !== undefined ? value : key;
},
remove: function( owner, key ) {
	var i, name, camel,
		unlock = this.key( owner ),
		cache = this.cache[ unlock ];

	if ( key === undefined ) {
		this.cache[ unlock ] = {};

	} else {
		// Support array or space separated string of keys
		if ( jQuery.isArray( key ) ) {
			// If &quot;name&quot; is an array of keys...
			// When data is initially created, via (&quot;key&quot;, &quot;val&quot;) signature,
			// keys will be converted to camelCase.
			// Since there is no way to tell _how_ a key was added, remove
			// both plain key and camelCase key. #12786
			// This will only penalize the array argument path.
			name = key.concat( key.map( jQuery.camelCase ) );
		} else {
			camel = jQuery.camelCase( key );
			// Try the string as a key before any manipulation
			if ( key in cache ) {
				name = [ key, camel ];
			} else {
				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				name = camel;
				name = name in cache ?
					[ name ] : ( name.match( rnotwhite ) || [] );
			}
		}

		i = name.length;
		while ( i-- ) {
			delete cache[ name[ i ] ];
		}
	}
},
hasData: function( owner ) {
	return !jQuery.isEmptyObject(
		this.cache[ owner[ this.expando ] ] || {}
	);
},
discard: function( owner ) {
	if ( owner[ this.expando ] ) {
		delete this.cache[ owner[ this.expando ] ];
	}
}
};
var data_priv = new Data();</code></pre>
          <section id="rbrace">
            <h1>rbrace</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-success radius ctx-type">declaration</div><span>&nbsp;</span><span>rbrace</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Implementation Summary</p><pre><code>1. Enforce API surface and semantic compatibility with 1.9.x branch
2. Improve the module&#39;s maintainability by reducing the storage
    paths to a single mechanism.
3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.
4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)
5. Avoid exposing implementation details on user objects (eg. expando properties)
6. Provide a clear path for implementation upgrade to WeakMap in 2014
</code></pre></div>
          <pre><code class="language-javascript">var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {
		name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$1&quot; ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === &quot;string&quot; ) {
			try {
				data = data === &quot;true&quot; ? true :
					data === &quot;false&quot; ? false :
					data === &quot;null&quot; ? null :
					// Only convert to a number if it doesn't change the string
					+data + &quot;&quot; === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem &amp;&amp; elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 &amp;&amp; !data_priv.get( elem, &quot;hasDataAttrs&quot; ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, &quot;hasDataAttrs&quot;, true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === &quot;object&quot; ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem &amp;&amp; value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to &quot;discover&quot; the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf(&quot;-&quot;) !== -1 &amp;&amp; data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length &gt; 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var strundefined = typeof undefined;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}</code></pre>
          <section id="event">
            <h1>event</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-success radius ctx-type">property</div><span>&nbsp;</span><span>jQuery.event</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Helper functions for managing events -- not part of the public interface.<br />Props to Dean Edwards&#39; addEvent library for many of the ideas.</p></div>
          <pre><code class="language-javascript">jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined &amp;&amp; jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || &quot;&quot; ).match( rnotwhite ) || [ &quot;&quot; ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(&quot;.&quot;)
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) &amp;&amp; data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || &quot;&quot; ).match( rnotwhite ) || [ &quot;&quot; ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] &amp;&amp; new RegExp( &quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot; );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
					( !handler || handler.guid === handleObj.guid ) &amp;&amp;
					( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
					( !selector || selector === handleObj.selector || selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount &amp;&amp; !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, &quot;events&quot; );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, &quot;type&quot; ) ? event.type : event,
			namespaces = hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split(&quot;.&quot;) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(&quot;.&quot;) &gt;= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(&quot;.&quot;);
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(&quot;:&quot;) &lt; 0 &amp;&amp; &quot;on&quot; + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === &quot;object&quot; &amp;&amp; event );

		// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(&quot;.&quot;);
		event.namespace_re = event.namespace ?
			new RegExp( &quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot; ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) {

			event.type = i &gt; 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp; data_priv.get( cur, &quot;handle&quot; );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype &amp;&amp; cur[ ontype ];
			if ( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &amp;&amp;
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, &quot;events&quot; ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG &lt;use&gt; instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== &quot;click&quot;) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== &quot;click&quot; ) {
					matches = [];
					for ( i = 0; i &lt; delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + &quot; &quot;;

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) &gt;= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount &lt; handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: &quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;.split(&quot; &quot;),

	fixHooks: {},

	keyHooks: {
		props: &quot;char charCode key keyCode&quot;.split(&quot; &quot;),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: &quot;button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement&quot;.split(&quot; &quot;),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null &amp;&amp; original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which &amp;&amp; button !== undefined ) {
				event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome &lt; 28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() &amp;&amp; this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: &quot;focusin&quot;
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() &amp;&amp; this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: &quot;focusout&quot;
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === &quot;checkbox&quot; &amp;&amp; this.click &amp;&amp; jQuery.nodeName( this, &quot;input&quot; ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, &quot;a&quot; );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined &amp;&amp; event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src &amp;&amp; src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &amp;&amp;
				// Support: Android &lt; 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e &amp;&amp; e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e &amp;&amp; e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e &amp;&amp; e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: &quot;mouseover&quot;,
	mouseleave: &quot;mouseout&quot;,
	pointerenter: &quot;pointerover&quot;,
	pointerleave: &quot;pointerout&quot;
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Create &quot;bubbling&quot; focus and blur events
// Support: Firefox, Chrome, Safari
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn,</code></pre>
          <div class="description"><p>INTERNAL</p></div>
          <pre><code class="language-javascript">one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === &quot;object&quot; ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== &quot;string&quot; ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null &amp;&amp; fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === &quot;string&quot; ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + &quot;.&quot; + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === &quot;object&quot; ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === &quot;function&quot; ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});
var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + &quot;&quot; );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== &quot;string&quot; ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, &quot;text/xml&quot; );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
		jQuery.error( &quot;Invalid XML: &quot; + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&amp;])_=[^&amp;]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,</code></pre>
          <div class="description"><p>Prefilters<br />1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)<br />2) These are called:</p><ul>
<li>BEFORE asking for a transport</li>
<li>AFTER param serialization (s.data is a string if s.processData is true)<br />3) key is the dataType<br />4) the catchall symbol &quot;<em>&quot; can be used<br />5) execution will start with transport dataType and THEN continue down to &quot;</em>&quot; if needed</li>
</ul>
</div>
          <pre><code class="language-javascript">prefilters = {},</code></pre>
          <div class="description"><p>Transports bindings<br />1) key is the dataType<br />2) the catchall symbol &quot;<em>&quot; can be used<br />3) selection will start with transport dataType and THEN go to &quot;</em>&quot; if needed</p></div>
          <pre><code class="language-javascript">transports = {},

// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
allTypes = &quot;*/&quot;.concat(&quot;*&quot;);

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
ajaxLocation = location.href;
} catch( e ) {
// Use the href attribute of an A element
// since IE will modify it given document.location
ajaxLocation = document.createElement( &quot;a&quot; );
ajaxLocation.href = &quot;&quot;;
ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

// dataTypeExpression is optional and defaults to &quot;*&quot;
return function( dataTypeExpression, func ) {

	if ( typeof dataTypeExpression !== &quot;string&quot; ) {
		func = dataTypeExpression;
		dataTypeExpression = &quot;*&quot;;
	}

	var dataType,
		i = 0,
		dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

	if ( jQuery.isFunction( func ) ) {
		// For each dataType in the dataTypeExpression
		while ( (dataType = dataTypes[i++]) ) {
			// Prepend if requested
			if ( dataType[0] === &quot;+&quot; ) {
				dataType = dataType.slice( 1 ) || &quot;*&quot;;
				(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

			// Otherwise append
			} else {
				(structure[ dataType ] = structure[ dataType ] || []).push( func );
			}
		}
	}
};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

var inspected = {},
	seekingTransport = ( structure === transports );

function inspect( dataType ) {
	var selected;
	inspected[ dataType ] = true;
	jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
		var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
		if ( typeof dataTypeOrTransport === &quot;string&quot; &amp;&amp; !seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {
			options.dataTypes.unshift( dataTypeOrTransport );
			inspect( dataTypeOrTransport );
			return false;
		} else if ( seekingTransport ) {
			return !( selected = dataTypeOrTransport );
		}
	});
	return selected;
}

return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; );
}

// A special extend for ajax options
// that takes &quot;flat&quot; options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
var key, deep,
	flatOptions = jQuery.ajaxSettings.flatOptions || {};

for ( key in src ) {
	if ( src[ key ] !== undefined ) {
		( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
	}
}
if ( deep ) {
	jQuery.extend( true, target, deep );
}

return target;
}</code></pre>
          <section id="ajaxHandleResponses">
            <h1>ajaxHandleResponses</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>ajaxHandleResponses()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Handles responses to an ajax request:</p><ul>
<li>finds the right dataType (mediates between content-type and expected dataType)</li>
<li>returns the corresponding response</li>
</ul>
</div>
          <pre><code class="language-javascript">function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === &quot;*&quot; ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader(&quot;Content-Type&quot;);
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}</code></pre>
          <section id="ajaxConvert">
            <h1>ajaxConvert</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>ajaxConvert()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Chain conversions given the request and the original response<br />Also sets the responseXXX fields on the jqXHR instance</p></div>
          <pre><code class="language-javascript">function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === &quot;*&quot; ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( &quot; &quot; );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
								converters[ &quot;* &quot; + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv &amp;&amp; s[ &quot;throws&quot; ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: &quot;parsererror&quot;, error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current };
						}
					}
				}
			}
		}
	}

	return { state: &quot;success&quot;, data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: &quot;GET&quot;,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,</code></pre>
          <section id="accepts">
            <h1>accepts</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-success radius ctx-type">property</div><span>&nbsp;</span><span>accepts</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>timeout: 0,<br />        data: null,<br />        dataType: null,<br />        username: null,<br />        password: null,<br />        cache: null,<br />        throws: false,<br />        traditional: false,<br />        headers: {},</p></div>
          <pre><code class="language-javascript">accepts: {
	&quot;*&quot;: allTypes,
	text: &quot;text/plain&quot;,
	html: &quot;text/html&quot;,
	xml: &quot;application/xml, text/xml&quot;,
	json: &quot;application/json, text/javascript&quot;
},

contents: {
	xml: /xml/,
	html: /html/,
	json: /json/
},

responseFields: {
	xml: &quot;responseXML&quot;,
	text: &quot;responseText&quot;,
	json: &quot;responseJSON&quot;
},

// Data converters
// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space
converters: {

	// Convert anything to text
	&quot;* text&quot;: String,

	// Text to html (true = no transformation)
	&quot;text html&quot;: true,

	// Evaluate text as a json expression
	&quot;text json&quot;: jQuery.parseJSON,

	// Parse text as xml
	&quot;text xml&quot;: jQuery.parseXML
},

// For options that shouldn't be deep extended:
// you can add your own custom options here if
// and when you create one that shouldn't be
// deep extended (see ajaxExtend)
flatOptions: {
	url: true,
	context: true
}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
return settings ?

	// Building a settings object
	ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

	// Extending ajaxSettings
	ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

// If url is an object, simulate pre-1.5 signature
if ( typeof url === &quot;object&quot; ) {
	options = url;
	url = undefined;
}

// Force options to be an object
options = options || {};

var transport,
	// URL without anti-cache param
	cacheURL,
	// Response headers
	responseHeadersString,
	responseHeaders,
	// timeout handle
	timeoutTimer,
	// Cross-domain detection vars
	parts,
	// To know if global events are to be dispatched
	fireGlobals,
	// Loop variable
	i,
	// Create the final options object
	s = jQuery.ajaxSetup( {}, options ),
	// Callbacks context
	callbackContext = s.context || s,
	// Context for global events is callbackContext if it is a DOM node or jQuery collection
	globalEventContext = s.context &amp;&amp; ( callbackContext.nodeType || callbackContext.jquery ) ?
		jQuery( callbackContext ) :
		jQuery.event,
	// Deferreds
	deferred = jQuery.Deferred(),
	completeDeferred = jQuery.Callbacks(&quot;once memory&quot;),
	// Status-dependent callbacks
	statusCode = s.statusCode || {},
	// Headers (they are sent all at once)
	requestHeaders = {},
	requestHeadersNames = {},
	// The jqXHR state
	state = 0,
	// Default abort message
	strAbort = &quot;canceled&quot;,
	// Fake xhr
	jqXHR = {
		readyState: 0,

		// Builds headers hashtable if needed
		getResponseHeader: function( key ) {
			var match;
			if ( state === 2 ) {
				if ( !responseHeaders ) {
					responseHeaders = {};
					while ( (match = rheaders.exec( responseHeadersString )) ) {
						responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
					}
				}
				match = responseHeaders[ key.toLowerCase() ];
			}
			return match == null ? null : match;
		},

		// Raw string
		getAllResponseHeaders: function() {
			return state === 2 ? responseHeadersString : null;
		},

		// Caches the header
		setRequestHeader: function( name, value ) {
			var lname = name.toLowerCase();
			if ( !state ) {
				name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
				requestHeaders[ name ] = value;
			}
			return this;
		},

		// Overrides response content-type header
		overrideMimeType: function( type ) {
			if ( !state ) {
				s.mimeType = type;
			}
			return this;
		},

		// Status-dependent callbacks
		statusCode: function( map ) {
			var code;
			if ( map ) {
				if ( state &lt; 2 ) {
					for ( code in map ) {
						// Lazy-add the new callback in a way that preserves old ones
						statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
					}
				} else {
					// Execute the appropriate callbacks
					jqXHR.always( map[ jqXHR.status ] );
				}
			}
			return this;
		},

		// Cancel the request
		abort: function( statusText ) {
			var finalText = statusText || strAbort;
			if ( transport ) {
				transport.abort( finalText );
			}
			done( 0, finalText );
			return this;
		}
	};

// Attach deferreds
deferred.promise( jqXHR ).complete = completeDeferred.add;
jqXHR.success = jqXHR.done;
jqXHR.error = jqXHR.fail;

// Remove hash character (#7531: and string promotion)
// Add protocol if not provided (prefilters might expect it)
// Handle falsy url in the settings object (#10093: consistency with old signature)
// We also use the url parameter if available
s.url = ( ( url || s.url || ajaxLocation ) + &quot;&quot; ).replace( rhash, &quot;&quot; )
	.replace( rprotocol, ajaxLocParts[ 1 ] + &quot;//&quot; );

// Alias method option to type as per ticket #12004
s.type = options.method || options.type || s.method || s.type;

// Extract dataTypes list
s.dataTypes = jQuery.trim( s.dataType || &quot;*&quot; ).toLowerCase().match( rnotwhite ) || [ &quot;&quot; ];

// A cross-domain request is in order when we have a protocol:host:port mismatch
if ( s.crossDomain == null ) {
	parts = rurl.exec( s.url.toLowerCase() );
	s.crossDomain = !!( parts &amp;&amp;
		( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
			( parts[ 3 ] || ( parts[ 1 ] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot; ) ) !==
				( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot; ) ) )
	);
}

// Convert data if not already a string
if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
	s.data = jQuery.param( s.data, s.traditional );
}

// Apply prefilters
inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

// If request was aborted inside a prefilter, stop there
if ( state === 2 ) {
	return jqXHR;
}

// We can fire global events as of now if asked to
fireGlobals = s.global;

// Watch for a new set of requests
if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
	jQuery.event.trigger(&quot;ajaxStart&quot;);
}

// Uppercase the type
s.type = s.type.toUpperCase();

// Determine if request has content
s.hasContent = !rnoContent.test( s.type );

// Save the URL in case we're toying with the If-Modified-Since
// and/or If-None-Match header later on
cacheURL = s.url;

// More options handling for requests with no content
if ( !s.hasContent ) {

	// If data is available, append data to url
	if ( s.data ) {
		cacheURL = ( s.url += ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data );
		// #9682: remove data so that it's not used in an eventual retry
		delete s.data;
	}

	// Add anti-cache in url if needed
	if ( s.cache === false ) {
		s.url = rts.test( cacheURL ) ?

			// If there is already a '_' parameter, set its value
			cacheURL.replace( rts, &quot;$1_=&quot; + nonce++ ) :

			// Otherwise add one to the end
			cacheURL + ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + nonce++;
	}
}

// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
if ( s.ifModified ) {
	if ( jQuery.lastModified[ cacheURL ] ) {
		jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] );
	}
	if ( jQuery.etag[ cacheURL ] ) {
		jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] );
	}
}

// Set the correct header, if data is being sent
if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
	jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
}

// Set the Accepts header for the server, depending on the dataType
jqXHR.setRequestHeader(
	&quot;Accept&quot;,
	s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?
		s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
		s.accepts[ &quot;*&quot; ]
);

// Check for headers option
for ( i in s.headers ) {
	jqXHR.setRequestHeader( i, s.headers[ i ] );
}

// Allow custom headers/mimetypes and early abort
if ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
	// Abort if not done already and return
	return jqXHR.abort();
}

// aborting is no longer a cancellation
strAbort = &quot;abort&quot;;

// Install callbacks on deferreds
for ( i in { success: 1, error: 1, complete: 1 } ) {
	jqXHR[ i ]( s[ i ] );
}

// Get transport
transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

// If no transport, we auto-abort
if ( !transport ) {
	done( -1, &quot;No Transport&quot; );
} else {
	jqXHR.readyState = 1;

	// Send global event
	if ( fireGlobals ) {
		globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
	}
	// Timeout
	if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
		timeoutTimer = setTimeout(function() {
			jqXHR.abort(&quot;timeout&quot;);
		}, s.timeout );
	}

	try {
		state = 1;
		transport.send( requestHeaders, done );
	} catch ( e ) {
		// Propagate exception as error if not done
		if ( state &lt; 2 ) {
			done( -1, e );
		// Simply rethrow otherwise
		} else {
			throw e;
		}
	}
}

// Callback for when everything is done
function done( status, nativeStatusText, responses, headers ) {
	var isSuccess, success, error, response, modified,
		statusText = nativeStatusText;

	// Called once
	if ( state === 2 ) {
		return;
	}

	// State is &quot;done&quot; now
	state = 2;

	// Clear timeout if it exists
	if ( timeoutTimer ) {
		clearTimeout( timeoutTimer );
	}

	// Dereference transport for early garbage collection
	// (no matter how long the jqXHR object will be used)
	transport = undefined;

	// Cache response headers
	responseHeadersString = headers || &quot;&quot;;

	// Set readyState
	jqXHR.readyState = status &gt; 0 ? 4 : 0;

	// Determine if successful
	isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;

	// Get response data
	if ( responses ) {
		response = ajaxHandleResponses( s, jqXHR, responses );
	}

	// Convert no matter what (that way responseXXX fields are always set)
	response = ajaxConvert( s, response, jqXHR, isSuccess );

	// If successful, handle type chaining
	if ( isSuccess ) {

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			modified = jqXHR.getResponseHeader(&quot;Last-Modified&quot;);
			if ( modified ) {
				jQuery.lastModified[ cacheURL ] = modified;
			}
			modified = jqXHR.getResponseHeader(&quot;etag&quot;);
			if ( modified ) {
				jQuery.etag[ cacheURL ] = modified;
			}
		}

		// if no content
		if ( status === 204 || s.type === &quot;HEAD&quot; ) {
			statusText = &quot;nocontent&quot;;

		// if not modified
		} else if ( status === 304 ) {
			statusText = &quot;notmodified&quot;;

		// If we have data, let's convert it
		} else {
			statusText = response.state;
			success = response.data;
			error = response.error;
			isSuccess = !error;
		}
	} else {
		// We extract error from statusText
		// then normalize statusText and status for non-aborts
		error = statusText;
		if ( status || !statusText ) {
			statusText = &quot;error&quot;;
			if ( status &lt; 0 ) {
				status = 0;
			}
		}
	}

	// Set data for the fake xhr object
	jqXHR.status = status;
	jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;;

	// Success/Error
	if ( isSuccess ) {
		deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
	} else {
		deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
	}

	// Status-dependent callbacks
	jqXHR.statusCode( statusCode );
	statusCode = undefined;

	if ( fireGlobals ) {
		globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;,
			[ jqXHR, s, isSuccess ? success : error ] );
	}

	// Complete
	completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

	if ( fireGlobals ) {
		globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );
		// Handle the global AJAX counter
		if ( !( --jQuery.active ) ) {
			jQuery.event.trigger(&quot;ajaxStop&quot;);
		}
	}
}

return jqXHR;
	},

	getJSON: function( url, data, callback ) {
return jQuery.get( url, data, callback, &quot;json&quot; );
	},

	getScript: function( url, callback ) {
return jQuery.get( url, undefined, callback, &quot;script&quot; );
	}
});

jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
// shift arguments if data argument was omitted
if ( jQuery.isFunction( data ) ) {
	type = type || callback;
	callback = data;
	data = undefined;
}

return jQuery.ajax({
	url: url,
	type: method,
	dataType: type,
	data: data,
	success: callback
});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ &quot;ajaxStart&quot;, &quot;ajaxStop&quot;, &quot;ajaxComplete&quot;, &quot;ajaxError&quot;, &quot;ajaxSuccess&quot;, &quot;ajaxSend&quot; ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
return this.on( type, fn );
	};
});


var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
// Serialize array item.
jQuery.each( obj, function( i, v ) {
	if ( traditional || rbracket.test( prefix ) ) {
		// Treat each array item as a scalar.
		add( prefix, v );

	} else {
		// Item is non-scalar (array or object), encode its numeric index.
		buildParams( prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; ? i : &quot;&quot; ) + &quot;]&quot;, v, traditional, add );
	}
});

	} else if ( !traditional &amp;&amp; jQuery.type( obj ) === &quot;object&quot; ) {
// Serialize object item.
for ( name in obj ) {
	buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
}

	} else {
// Serialize scalar item.
add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
s = [],
add = function( key, value ) {
	// If value is a function, invoke it and return its value
	value = jQuery.isFunction( value ) ? value() : ( value == null ? &quot;&quot; : value );
	s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; + encodeURIComponent( value );
};

	// Set traditional to true for jQuery &lt;= 1.3.2 behavior.
	if ( traditional === undefined ) {
traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {
// Serialize the form elements
jQuery.each( a, function() {
	add( this.name, this.value );
});

	} else {
// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
// did it), otherwise encode params recursively.
for ( prefix in a ) {
	buildParams( prefix, a[ prefix ], traditional, add );
}
	}

	// Return the resulting serialization
	return s.join( &quot;&amp;&quot; ).replace( r20, &quot;+&quot; );
};

jQuery.fn.extend({
	serialize: function() {
return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
return this.map(function() {
	// Can add propHook for &quot;elements&quot; to filter or add form elements
	var elements = jQuery.prop( this, &quot;elements&quot; );
	return elements ? jQuery.makeArray( elements ) : this;
})
.filter(function() {
	var type = this.type;

	// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works
	return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp;
		rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;
		( this.checked || !rcheckableType.test( type ) );
})
.map(function( i, elem ) {
	var val = jQuery( this ).val();

	return val == null ?
		null :
		jQuery.isArray( val ) ?
			jQuery.map( val, function( val ) {
				return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
			}) :
			{ name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
// file protocol always yields status code 0, assume 200
0: 200,
// Support: IE9
// #1450: sometimes IE returns 1223 when it should be 204
1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( &quot;unload&quot;, function() {
for ( var key in xhrCallbacks ) {
	xhrCallbacks[ key ]();
}
	});
}

support.cors = !!xhrSupported &amp;&amp; ( &quot;withCredentials&quot; in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {
return {
	send: function( headers, complete ) {
		var i,
			xhr = options.xhr(),
			id = ++xhrId;

		xhr.open( options.type, options.url, options.async, options.username, options.password );

		// Apply custom fields if provided
		if ( options.xhrFields ) {
			for ( i in options.xhrFields ) {
				xhr[ i ] = options.xhrFields[ i ];
			}
		}

		// Override mime type if needed
		if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {
			xhr.overrideMimeType( options.mimeType );
		}

		// X-Requested-With header
		// For cross-domain requests, seeing as conditions for a preflight are
		// akin to a jigsaw puzzle, we simply never set it to be sure.
		// (it can always be set on a per-request basis or even using ajaxSetup)
		// For same-domain requests, won't change header if already provided.
		if ( !options.crossDomain &amp;&amp; !headers[&quot;X-Requested-With&quot;] ) {
			headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;
		}

		// Set headers
		for ( i in headers ) {
			xhr.setRequestHeader( i, headers[ i ] );
		}

		// Callback
		callback = function( type ) {
			return function() {
				if ( callback ) {
					delete xhrCallbacks[ id ];
					callback = xhr.onload = xhr.onerror = null;

					if ( type === &quot;abort&quot; ) {
						xhr.abort();
					} else if ( type === &quot;error&quot; ) {
						complete(
							// file: protocol always yields status 0; see #8605, #14207
							xhr.status,
							xhr.statusText
						);
					} else {
						complete(
							xhrSuccessStatus[ xhr.status ] || xhr.status,
							xhr.statusText,
							// Support: IE9
							// Accessing binary-data responseText throws an exception
							// (#11426)
							typeof xhr.responseText === &quot;string&quot; ? {
								text: xhr.responseText
							} : undefined,
							xhr.getAllResponseHeaders()
						);
					}
				}
			};
		};

		// Listen to events
		xhr.onload = callback();
		xhr.onerror = callback(&quot;error&quot;);

		// Create the abort callback
		callback = xhrCallbacks[ id ] = callback(&quot;abort&quot;);

		try {
			// Do send the request (this may raise an exception)
			xhr.send( options.hasContent &amp;&amp; options.data || null );
		} catch ( e ) {
			// #14683: Only rethrow if this hasn't been notified as an error yet
			if ( callback ) {
				throw e;
			}
		}
	},

	abort: function() {
		if ( callback ) {
			callback();
		}
	}
};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
script: &quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;
	},
	contents: {
script: /(?:java|ecma)script/
	},
	converters: {
&quot;text script&quot;: function( text ) {
	jQuery.globalEval( text );
	return text;
}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
	if ( s.cache === undefined ) {
s.cache = false;
	}
	if ( s.crossDomain ) {
s.type = &quot;GET&quot;;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( &quot;script&quot;, function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
var script, callback;
return {
	send: function( _, complete ) {
		script = jQuery(&quot;&lt;script&gt;&quot;).prop({
			async: true,
			charset: s.scriptCharset,
			src: s.url
		}).on(
			&quot;load error&quot;,
			callback = function( evt ) {
				script.remove();
				callback = null;
				if ( evt ) {
					complete( evt.type === &quot;error&quot; ? 404 : 200, evt.type );
				}
			}
		);
		document.head.appendChild( script[ 0 ] );
	},
	abort: function() {
		if ( callback ) {
			callback();
		}
	}
};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&amp;|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: &quot;callback&quot;,
	jsonpCallback: function() {
var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
this[ callback ] = true;
return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?
	&quot;url&quot; :
	typeof s.data === &quot;string&quot; &amp;&amp; !( s.contentType || &quot;&quot; ).indexOf(&quot;application/x-www-form-urlencoded&quot;) &amp;&amp; rjsonp.test( s.data ) &amp;&amp; &quot;data&quot;
);

	// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === &quot;jsonp&quot; ) {

// Get callback name, remembering preexisting value associated with it
callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
	s.jsonpCallback() :
	s.jsonpCallback;

// Insert callback into url or form data
if ( jsonProp ) {
	s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName );
} else if ( s.jsonp !== false ) {
	s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName;
}

// Use data converter to retrieve json after script execution
s.converters[&quot;script json&quot;] = function() {
	if ( !responseContainer ) {
		jQuery.error( callbackName + &quot; was not called&quot; );
	}
	return responseContainer[ 0 ];
};

// force json dataType
s.dataTypes[ 0 ] = &quot;json&quot;;

// Install callback
overwritten = window[ callbackName ];
window[ callbackName ] = function() {
	responseContainer = arguments;
};

// Clean-up function (fires after converters)
jqXHR.always(function() {
	// Restore preexisting value
	window[ callbackName ] = overwritten;

	// Save back as free
	if ( s[ callbackName ] ) {
		// make sure that re-using the options doesn't screw things around
		s.jsonpCallback = originalSettings.jsonpCallback;

		// save the callback name for future use
		oldCallbacks.push( callbackName );
	}

	// Call if it was a function and we have a response
	if ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) {
		overwritten( responseContainer[ 0 ] );
	}

	responseContainer = overwritten = undefined;
});

// Delegate to script
return &quot;script&quot;;
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== &quot;string&quot; ) {
return null;
	}
	if ( typeof context === &quot;boolean&quot; ) {
keepScripts = context;
context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
scripts = !keepScripts &amp;&amp; [];

	// Single tag
	if ( parsed ) {
return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts &amp;&amp; scripts.length ) {
jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;</code></pre>
          <section id="load">
            <h1>load</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>jQuery.fn.load()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Load a url into a page</p></div>
          <pre><code class="language-javascript">jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== &quot;string&quot; &amp;&amp; _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(&quot; &quot;);

	if ( off &gt;= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params &amp;&amp; typeof params === &quot;object&quot; ) {
		type = &quot;POST&quot;;
	}

	// If we have elements to modify, make the request
	if ( self.length &gt; 0 ) {
		jQuery.ajax({
			url: url,

			// if &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used
			type: type,
			dataType: &quot;html&quot;,
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery(&quot;&lt;div&gt;&quot;).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback &amp;&amp; function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};



jQuery.noConflict = function() {};



return jQuery;
return jQuery;
}));

},{}],12:[function(require,module,exports){
&quot;use strict&quot;;
module.exports = function(document) {
  return {
    reload: function() {
      return document.location.reload();
    },
    getHash: function() {
      return document.location.hash;
    },
    setHash: function(newHash) {
      return document.location.hash = newHash;
    },
    changeHref: function(newLocation) {
      return document.location.href = newLocation;
    }
  };
};

},{}],13:[function(require,module,exports){
&quot;use strict&quot;;
var useCache;

useCache = function(callback) {
  var cacheobj;
  cacheobj = localStorage.getItem('oauthio_cache');
  if (cacheobj) {
    cacheobj = JSON.parse(cacheobj);
  } else {
    cacheobj = {};
  }
  return callback(cacheobj, function() {
    return localStorage.setItem('oauthio_cache', JSON.stringify(cacheobj));
  });
};

module.exports = {
  init: function(config, document) {
    this.config = config;
    return this.document = document;
  },
  active: function() {
    return typeof localStorage !== &quot;undefined&quot; &amp;&amp; localStorage !== null;
  },
  create: function(name, value, expires) {
    var date;
    this.erase(name);
    date = new Date();
    localStorage.setItem(name, value);
    useCache(function(cacheobj, cacheupdate) {
      cacheobj[name] = expires != null ? expires : date.getTime() + (expires || 1200) * {
        1000: false
      };
      return cacheupdate();
    });
  },
  read: function(name) {
    return useCache(function(cacheobj, cacheupdate) {
      if (cacheobj[name] == null) {
        return null;
      }
      if (cacheobj[name] === false) {
        return localStorage.getItem(name);
      } else if ((new Date()).getTime() &lt; cacheobj[name]) {
        localStorage.removeItem(name);
        delete cacheobj[name];
        cacheupdate();
        return null;
      } else {
        return localStorage.getItem(name);
      }
    });
  },
  erase: function(name) {
    return useCache(function(cacheobj, cacheupdate) {
      localStorage.removeItem(name);
      delete cacheobj[name];
      return cacheupdate();
    });
  },
  eraseFrom: function(prefix) {
    useCache(function(cacheobj, cacheupdate) {
      var cachenames, i, len, name;
      cachenames = Object.keys(cacheobj);
      for (i = 0, len = cachenames.length; i &lt; len; i++) {
        name = cachenames[i];
        if (name.substr(0, prefix.length) === prefix) {
          localStorage.removeItem(name);
          delete cacheobj[name];
        }
      }
      return cacheupdate();
    });
  }
};

},{}],14:[function(require,module,exports){
var b64pad, hexcase;

hexcase = 0;

b64pad = &quot;&quot;;</code></pre>
          <section id="exports">
            <h1>exports</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-success radius ctx-type">property</div><span>&nbsp;</span><span>module.exports</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>istanbul ignore next</p></div>
          <pre><code class="language-javascript">module.exports = {
  hex_sha1: function(s) {
    return this.rstr2hex(this.rstr_sha1(this.str2rstr_utf8(s)));
  },
  b64_sha1: function(s) {
    return this.rstr2b64(this.rstr_sha1(this.str2rstr_utf8(s)));
  },
  any_sha1: function(s, e) {
    return this.rstr2any(this.rstr_sha1(this.str2rstr_utf8(s)), e);
  },
  hex_hmac_sha1: function(k, d) {
    return this.rstr2hex(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)));
  },
  b64_hmac_sha1: function(k, d) {
    return this.rstr2b64(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)));
  },
  any_hmac_sha1: function(k, d, e) {
    return this.rstr2any(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)), e);
  },
  sha1_vm_test: function() {
    return thishex_sha1(&quot;abc&quot;).toLowerCase() === &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
  },
  rstr_sha1: function(s) {
    return this.binb2rstr(this.binb_sha1(this.rstr2binb(s), s.length * 8));
  },
  rstr_hmac_sha1: function(key, data) {
    var bkey, hash, i, ipad, opad;
    bkey = this.rstr2binb(key);
    if (bkey.length &gt; 16) {
      bkey = this.binb_sha1(bkey, key.length * 8);
    }
    ipad = Array(16);
    opad = Array(16);
    i = 0;
    while (i &lt; 16) {
      ipad[i] = bkey[i] ^ 0x36363636;
      opad[i] = bkey[i] ^ 0x5C5C5C5C;
      i++;
    }
    hash = this.binb_sha1(ipad.concat(this.rstr2binb(data)), 512 + data.length * 8);
    return this.binb2rstr(this.binb_sha1(opad.concat(hash), 512 + 160));
  },
  rstr2hex: function(input) {
    var e, hex_tab, i, output, x;
    try {
      hexcase;
    } catch (_error) {
      e = _error;
      hexcase = 0;
    }
    hex_tab = (hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;);
    output = &quot;&quot;;
    x = void 0;
    i = 0;
    while (i &lt; input.length) {
      x = input.charCodeAt(i);
      output += hex_tab.charAt((x &gt;&gt;&gt; 4) &amp; 0x0F) + hex_tab.charAt(x &amp; 0x0F);
      i++;
    }
    return output;
  },
  rstr2b64: function(input) {
    var e, i, j, len, output, tab, triplet;
    try {
      b64pad;
    } catch (_error) {
      e = _error;
      b64pad = &quot;&quot;;
    }
    tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
    output = &quot;&quot;;
    len = input.length;
    i = 0;
    while (i &lt; len) {
      triplet = (input.charCodeAt(i) &lt;&lt; 16) | (i + 1 &lt; len ? input.charCodeAt(i + 1) &lt;&lt; 8 : 0) | (i + 2 &lt; len ? input.charCodeAt(i + 2) : 0);
      j = 0;
      while (j &lt; 4) {
        if (i * 8 + j * 6 &gt; input.length * 8) {
          output += b64pad;
        } else {
          output += tab.charAt((triplet &gt;&gt;&gt; 6 * (3 - j)) &amp; 0x3F);
        }
        j++;
      }
      i += 3;
    }
    return output;
  },
  rstr2any: function(input, encoding) {
    var dividend, divisor, full_length, i, output, q, quotient, remainders, x;
    divisor = encoding.length;
    remainders = Array();
    i = void 0;
    q = void 0;
    x = void 0;
    quotient = void 0;
    dividend = Array(Math.ceil(input.length / 2));
    i = 0;
    while (i &lt; dividend.length) {
      dividend[i] = (input.charCodeAt(i * 2) &lt;&lt; 8) | input.charCodeAt(i * 2 + 1);
      i++;
    }
    while (dividend.length &gt; 0) {
      quotient = Array();
      x = 0;
      i = 0;
      while (i &lt; dividend.length) {
        x = (x &lt;&lt; 16) + dividend[i];
        q = Math.floor(x / divisor);
        x -= q * divisor;
        if (quotient.length &gt; 0 || q &gt; 0) {
          quotient[quotient.length] = q;
        }
        i++;
      }
      remainders[remainders.length] = x;
      dividend = quotient;
    }
    output = &quot;&quot;;
    i = remainders.length - 1;
    while (i &gt;= 0) {
      output += encoding.charAt(remainders[i]);
      i--;
    }
    full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
    i = output.length;
    while (i &lt; full_length) {
      output = encoding[0] + output;
      i++;
    }
    return output;
  },
  str2rstr_utf8: function(input) {
    var i, output, x, y;
    output = &quot;&quot;;
    i = -1;
    x = void 0;
    y = void 0;
    while (++i &lt; input.length) {
      x = input.charCodeAt(i);
      y = (i + 1 &lt; input.length ? input.charCodeAt(i + 1) : 0);
      if (0xD800 &lt;= x &amp;&amp; x &lt;= 0xDBFF &amp;&amp; 0xDC00 &lt;= y &amp;&amp; y &lt;= 0xDFFF) {
        x = 0x10000 + ((x &amp; 0x03FF) &lt;&lt; 10) + (y &amp; 0x03FF);
        i++;
      }
      if (x &lt;= 0x7F) {
        output += String.fromCharCode(x);
      } else if (x &lt;= 0x7FF) {
        output += String.fromCharCode(0xC0 | ((x &gt;&gt;&gt; 6) &amp; 0x1F), 0x80 | (x &amp; 0x3F));
      } else if (x &lt;= 0xFFFF) {
        output += String.fromCharCode(0xE0 | ((x &gt;&gt;&gt; 12) &amp; 0x0F), 0x80 | ((x &gt;&gt;&gt; 6) &amp; 0x3F), 0x80 | (x &amp; 0x3F));
      } else {
        if (x &lt;= 0x1FFFFF) {
          output += String.fromCharCode(0xF0 | ((x &gt;&gt;&gt; 18) &amp; 0x07), 0x80 | ((x &gt;&gt;&gt; 12) &amp; 0x3F), 0x80 | ((x &gt;&gt;&gt; 6) &amp; 0x3F), 0x80 | (x &amp; 0x3F));
        }
      }
    }
    return output;
  },
  str2rstr_utf16le: function(input) {
    var i, output;
    output = &quot;&quot;;
    i = 0;
    while (i &lt; input.length) {
      output += String.fromCharCode(input.charCodeAt(i) &amp; 0xFF, (input.charCodeAt(i) &gt;&gt;&gt; 8) &amp; 0xFF);
      i++;
    }
    return output;
  },
  str2rstr_utf16be: function(input) {
    var i, output;
    output = &quot;&quot;;
    i = 0;
    while (i &lt; input.length) {
      output += String.fromCharCode((input.charCodeAt(i) &gt;&gt;&gt; 8) &amp; 0xFF, input.charCodeAt(i) &amp; 0xFF);
      i++;
    }
    return output;
  },
  rstr2binb: function(input) {
    var i, output;
    output = Array(input.length &gt;&gt; 2);
    i = 0;
    while (i &lt; output.length) {
      output[i] = 0;
      i++;
    }
    i = 0;
    while (i &lt; input.length * 8) {
      output[i &gt;&gt; 5] |= (input.charCodeAt(i / 8) &amp; 0xFF) &lt;&lt; (24 - i % 32);
      i += 8;
    }
    return output;
  },
  binb2rstr: function(input) {
    var i, output;
    output = &quot;&quot;;
    i = 0;
    while (i &lt; input.length * 32) {
      output += String.fromCharCode((input[i &gt;&gt; 5] &gt;&gt;&gt; (24 - i % 32)) &amp; 0xFF);
      i += 8;
    }
    return output;
  },
  binb_sha1: function(x, len) {
    var a, b, c, d, e, i, j, olda, oldb, oldc, oldd, olde, t, w;
    x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
    x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
    w = Array(80);
    a = 1732584193;
    b = -271733879;
    c = -1732584194;
    d = 271733878;
    e = -1009589776;
    i = 0;
    while (i &lt; x.length) {
      olda = a;
      oldb = b;
      oldc = c;
      oldd = d;
      olde = e;
      j = 0;
      while (j &lt; 80) {
        if (j &lt; 16) {
          w[j] = x[i + j];
        } else {
          w[j] = this.bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
        }
        t = this.safe_add(this.safe_add(this.bit_rol(a, 5), this.sha1_ft(j, b, c, d)), this.safe_add(this.safe_add(e, w[j]), this.sha1_kt(j)));
        e = d;
        d = c;
        c = this.bit_rol(b, 30);
        b = a;
        a = t;
        j++;
      }
      a = this.safe_add(a, olda);
      b = this.safe_add(b, oldb);
      c = this.safe_add(c, oldc);
      d = this.safe_add(d, oldd);
      e = this.safe_add(e, olde);
      i += 16;
    }
    return Array(a, b, c, d, e);
  },
  sha1_ft: function(t, b, c, d) {
    if (t &lt; 20) {
      return (b &amp; c) | ((~b) &amp; d);
    }
    if (t &lt; 40) {
      return b ^ c ^ d;
    }
    if (t &lt; 60) {
      return (b &amp; c) | (b &amp; d) | (c &amp; d);
    }
    return b ^ c ^ d;
  },
  sha1_kt: function(t) {
    if (t &lt; 20) {
      return 1518500249;
    } else {
      if (t &lt; 40) {
        return 1859775393;
      } else {
        if (t &lt; 60) {
          return -1894007588;
        } else {
          return -899497514;
        }
      }
    }
  },
  safe_add: function(x, y) {
    var lsw, msw;
    lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
    msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
    return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
  },
  bit_rol: function(num, cnt) {
    return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
  },
  create_hash: function() {
    var hash;
    hash = this.b64_sha1((new Date()).getTime() + &quot;:&quot; + Math.floor(Math.random() * 9999999));
    return hash.replace(/\+/g, &quot;-&quot;).replace(/\//g, &quot;_&quot;).replace(/\=+$/, &quot;&quot;);
  }
};

},{}],15:[function(require,module,exports){
module.exports = function(document) {
  return {
    getAbsUrl: function(url) {
      var base_url;
      if (url.match(/^.{2,5}:\/\//)) {
        return url;
      }
      if (url[0] === &quot;/&quot;) {
        return document.location.protocol + &quot;//&quot; + document.location.host + url;
      }
      base_url = document.location.protocol + &quot;//&quot; + document.location.host + document.location.pathname;
      if (base_url[base_url.length - 1] !== &quot;/&quot; &amp;&amp; url[0] !== &quot;#&quot;) {
        return base_url + &quot;/&quot; + url;
      }
      return base_url + url;
    },
    replaceParam: function(param, rep, rep2) {
      param = param.replace(/\{\{(.*?)\}\}/g, function(m, v) {
        return rep[v] || &quot;&quot;;
      });
      if (rep2) {
        param = param.replace(/\{(.*?)\}/g, function(m, v) {
          return rep2[v] || &quot;&quot;;
        });
      }
      return param;
    }
  };
};

},{}]},{},[8])(8)
});</code></pre>
        </div>
      </div>
    </div>
    <footer class="footer">
      <div class="container">
        <p>Documentation generated with <a href="https://github.com/mr-doc/mr-doc">Mr. Doc </a> created by <a href="https://twitter.com/FGRibreau" data-show-count="false" class="twitter-follow-button">Francois-Guillaume Ribreau </a></p>
        <p>Mr. Doc is sponsored by <a href="http://bringr.net/?btt" title="Outil d'analyse des réseaux sociaux" class="bringr">Bringr </a> and <a href="https://redsmin.com/?btt" title="Full Redis GUI" class="redsmin">Redsmin</a></p>
        <p>Theme borrowed from Twitter Bootstrap</p>
      </div>
    </footer>
    <script src="../js/twitter-widget.min.js"></script>
    <script src="../js/jquery.min.js"></script>
    <script src="../js/bootstrap-transition.min.js"></script>
    <script src="../js/bootstrap-scrollspy.min.js"></script>
    <script src="../js/bootstrap-dropdown.min.js"></script>
    <script src="../js/bootstrap-collapse.min.js"></script>
    <script src="../js/bootstrap-affix.min.js"></script>
    <script src="../js/prism.min.js"></script>
    <script src="../js/index.min.js"></script>
  </body>
</html>